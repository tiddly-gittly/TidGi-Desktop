{
    "tiddlers": {
        "$:/plugins/flibbles/relink/js/fieldtypes/markdown.js": {
            "title": "$:/plugins/flibbles/relink/js/fieldtypes/markdown.js",
            "text": "/*\\\nmodule-type: relinkfieldtype\ntitle: $:/plugins/flibbles/relink/js/fieldtypes/markdown.js\ntype: application/javascript\n\nThis relinks tiddlers which contain markdown. It tries to be agnostic to\nwhichever markdown plugin you're using.\n\n\\*/\n\nvar EntryNode = require('$:/plugins/flibbles/relink/js/utils/entry');\nvar Rebuilder = require(\"$:/plugins/flibbles/relink/js/utils/rebuilder.js\");\nvar utils = require(\"$:/plugins/flibbles/relink/js/utils/markdown.js\");\nvar WikiParser = require(\"$:/core/modules/parsers/wikiparser/wikiparser.js\")['text/vnd.tiddlywiki'];\n\nvar MarkdownEntry = EntryNode.newType(\"markdown\");\n\nfunction MarkdownRelinker(text, fromTitle, toTitle, options) {\n\tthis.wiki = options.wiki;\n\tthis.entry = new MarkdownEntry();\n\tthis.builder = new Rebuilder(text);\n\tthis.fromTitle = fromTitle;\n\tthis.toTitle = toTitle;\n\tthis.options = options;\n\tif(!this.mdInlineRuleClasses) {\n\t\tMarkdownRelinker.prototype.mdInlineRuleClasses = $tw.modules.createClassesFromModules(\"relinkmarkdownrule\",\"inline\",$tw.MarkdownRuleBase);\n\t}\n\tif(!this.mdBlockRuleClasses) {\n\t\tMarkdownRelinker.prototype.mdBlockRuleClasses = $tw.modules.createClassesFromModules(\"relinkmarkdownrule\",\"block\",$tw.MarkdownRuleBase);\n\t}\n\tthis.source = text || \"\";\n\tthis.sourceLength = this.source.length;\n\t// Set current parse position\n\tthis.pos = 0;\n\t// Instantiate the parser block and inline rules\n\tthis.blockRules = this.instantiateRules(this.mdBlockRuleClasses,\"block\",0);\n\tthis.inlineRules = this.instantiateRules(this.mdInlineRuleClasses,\"inline\",0);\n\t// instantiateRules first with indent==undefined so we can match regardless\n\t// of tabdepth. Now we need to be strict about it.\n\tthis.indent = 0;\n\tthis.parseBlocks();\n};\n\nMarkdownRelinker.prototype = Object.create(WikiParser.prototype);\n\nmodule.exports\n\nMarkdownRelinker.prototype.parseBlock = function(terminatorRegExpString) {\n\tvar terminatorRegExp = /([^\\S\\n]*\\r?\\n)/mg;\n\tthis.skipEmptyLines();\n\tif(this.pos >= this.sourceLength) {\n\t\treturn [];\n\t}\n\t// Look for a block rule that applies at the current position\n\tvar nextMatch = this.findNextMatch(this.blockRules, this.pos);\n\tif(nextMatch && nextMatch.matchIndex === this.pos) {\n\t\treturn this.relinkRule(nextMatch);\n\t}\n\treturn this.parseInlineRun(terminatorRegExp);\n};\n\nMarkdownRelinker.prototype.relinkRule = function(ruleInfo) {\n\tvar newEntry = ruleInfo.rule.relink(this.source, this.fromTitle, this.toTitle, this.options);\n\tif (newEntry !== undefined) {\n\t\tthis.entry.add(newEntry);\n\t\tif (newEntry.output) {\n\t\t\tthis.builder.add(newEntry.output, ruleInfo.matchIndex, this.pos);\n\t\t}\n\t}\n};\n\nMarkdownRelinker.prototype.parseInlineRunTerminated = function(terminatorRegExp,options) {\n\toptions = options || {};\n\tvar tree = [];\n\t// Find the next occurrence of the terminator\n\tterminatorRegExp.lastIndex = this.pos;\n\tvar terminatorMatch = terminatorRegExp.exec(this.source);\n\t// Find the next occurrence of a inlinerule\n\tvar inlineRuleMatch = this.findNextMatch(this.inlineRules,this.pos);\n\t// Loop around until we've reached the end of the text\n\twhile(this.pos < this.sourceLength && (terminatorMatch || inlineRuleMatch)) {\n\t\t// Return if we've found the terminator, and it precedes any inline rule match\n\t\tif(terminatorMatch) {\n\t\t\tif(!inlineRuleMatch || inlineRuleMatch.matchIndex >= terminatorMatch.index) {\n\t\t\t\tthis.relinkWikitext(this.pos, terminatorMatch.index);\n\t\t\t\t//if(options.eatTerminator) {\n\t\t\t\t\tthis.pos += terminatorMatch[0].length;\n\t\t\t\t//}\n\t\t\t\treturn tree;\n\t\t\t}\n\t\t}\n\t\t// Process any inline rule, along with the text preceding it\n\t\tif(inlineRuleMatch) {\n\t\t\t// Preceding text\n\t\t\tthis.relinkWikitext(this.pos, inlineRuleMatch.matchIndex);\n\t\t\tthis.relinkRule(inlineRuleMatch);\n\t\t\t// Look for the next inline rule\n\t\t\tinlineRuleMatch = this.findNextMatch(this.inlineRules,this.pos);\n\t\t\t// Look for the next terminator match\n\t\t\tterminatorRegExp.lastIndex = this.pos;\n\t\t\tterminatorMatch = terminatorRegExp.exec(this.source);\n\t\t}\n\t}\n\t// Process the remaining text\n\tthis.relinkWikitext(this.pos, this.sourceLength);\n\treturn tree;\n};\n\nMarkdownRelinker.prototype.skipEmptyLines = function() {\n\tvar emptyRegExp = /(?:[^\\S\\n]*\\n)+/mg;\n\temptyRegExp.lastIndex = this.pos;\n\tvar emptyMatch = emptyRegExp.exec(this.source);\n\tif(emptyMatch && emptyMatch.index === this.pos) {\n\t\tthis.pos = emptyRegExp.lastIndex;\n\t}\n};\n\nMarkdownRelinker.prototype.relinkWikitext = function(startPos, end) {\n\tif (startPos < end) {\n\t\tvar config = utils.getSettings(this.wiki);\n\t\tif (config.wikitext) {\n\t\t\tvar substr = this.source.substring(this.pos, end);\n\n\t\t\tvar pragma = config.wikitextPragma;\n\t\t\tvar wikitextHandler = this.options.settings.getType('wikitext');\n\t\t\tvar wikiEntry = wikitextHandler.relink(pragma + substr, this.fromTitle, this.toTitle, this.options);\n\t\t\tif (wikiEntry != undefined) {\n\t\t\t\tthis.entry.add(wikiEntry);\n\t\t\t\tif (wikiEntry.output) {\n\t\t\t\t\tthis.builder.add(wikiEntry.output.slice(pragma.length), startPos, end);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tthis.pos = end;\n}\n\nexports.name = \"markdown\";\n\nexports.relink = function(markdowntext, fromTitle, toTitle, options) {\n\tvar relinker = new MarkdownRelinker(markdowntext, fromTitle, toTitle, options);\n\tvar entry = relinker.entry;\n\tif (entry.children.length > 0) {\n\t\tentry.output = relinker.builder.results();\n\t\treturn entry;\n\t}\n\treturn undefined;\n};\n",
            "module-type": "relinkfieldtype",
            "type": "application/javascript"
        },
        "$:/plugins/flibbles/relink/js/relinkoperations/text/markdowntext/codeblock.js": {
            "title": "$:/plugins/flibbles/relink/js/relinkoperations/text/markdowntext/codeblock.js",
            "text": "/*\\\nmodule-type: relinkmarkdownrule\ntitle: $:/plugins/flibbles/relink/js/relinkoperations/text/markdowntext/codeblock.js\ntype: application/javascript\n\n```javascript\ncode\n```\n\n\\*/\n\nvar utils = require(\"$:/plugins/flibbles/relink/js/utils/markdown\");\n\nexports.name = \"codeblock\";\nexports.types = {inline: true};\n\nexports.init = function(parser) {\n\tthis.parser = parser;\n\tthis.matchRegExp = /(```+)[^\\n`]*(?:\\n|$)/mg;\n\tthis.maxIndent = 3;\n};\n\nexports.relink = function(text, fromTitle, toTitle, options) {\n\tvar endRegExp = new RegExp(\"^ {0,3}\" + this.match[1] + \"+[^\\\\S\\\\n]*\\\\n\", \"mg\");\n\tendRegExp.lastIndex = this.matchRegExp.lastIndex;\n\tvar endMatch = endRegExp.exec(this.parser.source);\n\tif (endMatch) {\n\t\tthis.parser.pos = endRegExp.lastIndex;\n\t} else {\n\t\tthis.parser.pos = this.parser.sourceLength;\n\t}\n\treturn undefined;\n};\n",
            "module-type": "relinkmarkdownrule",
            "type": "application/javascript"
        },
        "$:/plugins/flibbles/relink/js/relinkoperations/text/markdowntext/codeinline.js": {
            "title": "$:/plugins/flibbles/relink/js/relinkoperations/text/markdowntext/codeinline.js",
            "text": "/*\\\nmodule-type: relinkmarkdownrule\ntitle: $:/plugins/flibbles/relink/js/relinkoperations/text/markdowntext/codeinline.js\ntype: application/javascript\n\nHandles markdown `code` and ``code``.\n\n\\*/\n\nvar utils = require(\"$:/plugins/flibbles/relink/js/utils/markdown\");\n\nexports.name = \"codeinline\";\nexports.types = {inline: true};\n\nexports.init = function(parser) {\n\tthis.parser = parser;\n};\n\nexports.findNextMatch = function(startPos) {\n\tvar match, matchRegExp = /`+/mg;\n\tmatchRegExp.lastIndex = startPos;\n\twhile (match = matchRegExp.exec(this.parser.source)) {\n\t\tvar next = this.parser.source.indexOf(match[0], matchRegExp.lastIndex);\n\t\t// make sure we find the corresponding ticks\n\t\tif (next >= 0) {\n\t\t\t// Make sure it's the right length\n\t\t\tvar end = next + match[0].length;\n\t\t\tif (match[0].length < 3 || !isLineStart(this.parser.source, next)) {\n\t\t\t\tif (this.parser.source.charAt(end) !== '`') {\n\t\t\t\t\t// make sure there aren't paragraph breaks between the points\n\t\t\t\t\tvar nextGraph = utils.indexOfParagraph(this.parser.source, matchRegExp.lastIndex);\n\t\t\t\t\tif (nextGraph < 0 || nextGraph > next) {\n\t\t\t\t\t\tthis.end = end;\n\t\t\t\t\t\treturn match.index;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn undefined;\n};\n\nfunction isLineStart(text, pos) {\n\t// if 3 or less spaces precede it, it's a line start.\n\tvar p = text.lastIndexOf('\\n', pos);\n\tif (pos - p > 3) {\n\t\treturn false;\n\t}\n\twhile (++p < pos) {\n\t\tif (text.charAt(p) !== ' ') {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n};\n\nexports.relink = function() {\n\tthis.parser.pos = this.end;\n\treturn undefined;\n};\n",
            "module-type": "relinkmarkdownrule",
            "type": "application/javascript"
        },
        "$:/plugins/flibbles/relink/js/relinkoperations/text/markdowntext/footnote.js": {
            "title": "$:/plugins/flibbles/relink/js/relinkoperations/text/markdowntext/footnote.js",
            "text": "/*\\\nmodule-type: relinkmarkdownrule\ntitle: $:/plugins/flibbles/relink/js/relinkoperations/text/markdowntext/footnote.js\ntype: application/javascript\n\nHandles markdown footnotes\n\n[1]: #link\n\n\\*/\n\nvar utils = require(\"$:/plugins/flibbles/relink/js/utils/markdown\");\n\nfunction FootnoteEntry() {};\nFootnoteEntry.prototype.name = \"markdownfootnote\";\nFootnoteEntry.prototype.report = function() {\n\treturn [\"[\" + utils.abridge(this.caption) + \"]:\"];\n};\n\nexports.name = \"markdownfootnote\";\nexports.types = {block: true};\n\nexports.init = function(parser) {\n\tthis.parser = parser;\n\tthis.matchRegExp = /\\[((?:[^\\\\\\]]|\\\\.)*)\\]:(\\s*)(#?)(\\S+)([^\\S\\n]*(?:\\n|$))/mg;\n\tthis.maxIndent = 3;\n};\n\nexports.relink = function(text, fromTitle, toTitle, options) {\n\tvar m = this.match,\n\t\tlink = m[4],\n\t\tentry;\n\tthis.parser.pos = m.index + m[0].length;\n\tif (m[1].charAt(0) !== \"^\"\n\t && (m[3] === \"#\" || options.wiki.isImageTiddler(toTitle))\n\t && decodeURIComponent(link) === fromTitle) {\n\t\tentry = new FootnoteEntry();\n\t\tentry.caption = m[1];\n\t\tentry.output = this.indentString + \"[\" + m[1] + \"]:\" + m[2] + m[3] + utils.encodeLink(toTitle) + m[5];\n\t}\n\treturn entry;\n};\n",
            "module-type": "relinkmarkdownrule",
            "type": "application/javascript"
        },
        "$:/plugins/flibbles/relink/js/relinkoperations/text/markdowntext/link.js": {
            "title": "$:/plugins/flibbles/relink/js/relinkoperations/text/markdowntext/link.js",
            "text": "/*\\\nmodule-type: relinkmarkdownrule\ntitle: $:/plugins/flibbles/relink/js/relinkoperations/text/markdowntext/link.js\ntype: application/javascript\n\nHandles markdown links\n\n[caption](#link)\n\n\\*/\n\nvar utils = require(\"$:/plugins/flibbles/relink/js/utils/markdown\");\nvar settings = require(\"$:/plugins/flibbles/relink/js/settings\");\nvar markdown = settings.getType('markdown');\n\nfunction LinkEntry() {};\nLinkEntry.prototype.name = \"markdownlink\";\nLinkEntry.prototype.report = function() {\n\tvar output = [];\n\tvar hash = '#';\n\tif (this.prefix) {\n\t\thash = '';\n\t}\n\tif (this.captionEntry) {\n\t\tvar self = this;\n\t\t$tw.utils.each(this.captionEntry.report(), function(report) {\n\t\t\toutput.push(self.prefix+\"[\" + (report || '') + \"](\" + hash + self.link + \")\");\n\t\t});\n\t};\n\tif (this.linkChanged) {\n\t\tvar safeCaption = utils.abridge(this.caption);\n\t\toutput.push(this.prefix+\"[\" + safeCaption + \"](\" + hash + \")\");\n\t}\n\treturn output;\n};\n\nLinkEntry.prototype.eachChild = function(method) {\n\tif (this.captionEntry) {\n\t\tmethod(this.captionEntry);\n\t}\n};\n\nexports.name = \"markdownlink\";\nexports.types = {inline: true};\n\nexports.init = function(parser) {\n\tthis.parser = parser;\n};\n\nexports.findNextMatch = function(startPos) {\n\tthis.endMatch = this.matchLink(this.parser.source, startPos);\n\treturn this.endMatch ? this.endMatch.index : undefined;\n};\n\nexports.survey = function(text) {\n\treturn this.matchLink(text, 0);\n};\n\n/**A zero side-effect method which returns a regexp which pretended to match\n * the whole link, caption and all. I do this instead of just using a\n * regexp to begin with, because markdown links require context-free grammar\n * matching.\n * Currently, it doesn't properly set match[0]. No need as of yet.\n * 1. \"!\"\n * 2. caption\n * 3. \"\\s*#?\"\n * 4. \"link\"\n * 5. \"\\s*'tooltip'\"\n */\nexports.matchLink = function(text, pos) {\n\tpos = pos-1;\n\tvar match = undefined;\n\tdo {\n\t\tpos = text.indexOf('[', pos+1);\n\t\tif (pos < 0) {\n\t\t\treturn undefined;\n\t\t}\n\t\tvar caption = this.getEnclosed(text, pos, '[', ']');\n\t\tif (caption === undefined) {\n\t\t\tcontinue;\n\t\t}\n\t\tvar linkStart = pos + caption.length+2;\n\t\tif (text.charAt(linkStart) !== '(') {\n\t\t\tcontinue;\n\t\t}\n\t\t// match[1] and match[2] are the \"!\" and \"caption\", filled in later.\n\t\tvar regExp = /\\(()()(\\s*#?)((?:[^\\s\\(\\)]|\\([^\\s\\(\\)]*\\))+)((?:\\s+(?:'(?:[^'\\\\]|\\\\.)*'|\"(?:[^\"\\\\]|\\\\.)*\"|\\([^)]*\\)))?\\s*)\\)/g;\n\t\tregExp.lastIndex = linkStart;\n\t\tmatch = regExp.exec(text);\n\t\tif (match && match.index === linkStart && utils.indexOfParagraph(match[0]) < 0) {\n\t\t\tmatch[2] = caption;\n\t\t\tif (text.charAt(pos-1) === \"!\") {\n\t\t\t\tmatch.index = pos-1;\n\t\t\t\tmatch[1] = \"!\";\n\t\t\t} else {\n\t\t\t\tmatch.index = pos;\n\t\t\t}\n\t\t} else {\n\t\t\tmatch = undefined;\n\t\t}\n\t} while (!match);\n\treturn match;\n};\n\nexports.relink = function(text, fromTitle, toTitle, options) {\n\tvar entry = new LinkEntry(),\n\t\tem = this.endMatch,\n\t\tmodified = false,\n\t\tcaption = em[2],\n\t\timage = (em[1] === '!'),\n\t\tlink = em[4];\n\tthis.parser.pos = em.index + em[1].length + caption.length + em[0].length + 2;\n\tif (!image) {\n\t\tvar newCaption = markdown.relink(caption, fromTitle, toTitle, options);\n\t\tif (newCaption) {\n\t\t\tmodified = true;\n\t\t\tentry.captionEntry = newCaption;\n\t\t\tif (newCaption.output) {\n\t\t\t\tif (this.canBeCaption(newCaption.output)) {\n\t\t\t\t\tcaption = newCaption.output;\n\t\t\t\t} else {\n\t\t\t\t\tnewCaption.impossible = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t// I don't know why internal images links don't use the '#', but links\n\t// do, but that's just how it is.\n\tif (image !== (em[3].lastIndexOf('#') >=0)) {\n\t\ttry {\n\t\t\tif (decodeURIComponent(link) === fromTitle) {\n\t\t\t\tmodified = true;\n\t\t\t\tentry.linkChanged = true;\n\t\t\t\tlink = utils.encodeLink(toTitle);\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t// It must be a malformed link. Not our problem.\n\t\t\t// Keep going in case the caption needs relinking.\n\t\t}\n\t}\n\tif (modified) {\n\t\tentry.link = link;\n\t\tentry.caption = caption;\n\t\tentry.prefix = em[1];\n\t\t// This way preserves whitespace\n\t\tentry.output = em[1]+\"[\"+caption+\"](\"+em[3]+link+em[5]+\")\";\n\t\treturn entry;\n\t}\n\treturn undefined;\n};\n\nexports.canBeCaption = function(caption) {\n\treturn this.indexOfClose(caption+']', -1, '[', ']') === caption.length;\n};\n\nexports.getEnclosed = function(text, pos, openChar, closeChar) {\n\tvar capEnd = this.indexOfClose(text, pos, openChar, closeChar);\n\tif (capEnd < 0) {\n\t\treturn undefined;\n\t}\n\tvar enclosed = text.substring(pos+1, capEnd);\n\tif (enclosed.match(/\\n\\s*\\n/)) {\n\t\t// Paragraph breaks are not allowed\n\t\treturn undefined;\n\t}\n\treturn enclosed;\n};\n\nexports.indexOfClose = function(text, pos, openChar, closeChar) {\n\tvar close = pos-1,\n\t\topen = pos; // First char is open\n\tdo {\n\t\tclose = text.indexOf(closeChar, close+1);\n\t\tif (close < 0) {\n\t\t\treturn -1;\n\t\t}\n\t\topen = text.indexOf(openChar, open+1);\n\t} while (open >= 0 && open <= close);\n\treturn close;\n};\n",
            "module-type": "relinkmarkdownrule",
            "type": "application/javascript"
        },
        "$:/plugins/flibbles/relink/js/relinkoperations/text/markdowntext/markdownrulebase.js": {
            "title": "$:/plugins/flibbles/relink/js/relinkoperations/text/markdowntext/markdownrulebase.js",
            "text": "/*\\\ntitle: $:/plugins/flibbles/relink/js/relinkoperations/text/markdowntext/markdownrulebase.js\ntype: application/javascript\nmodule-type: global\n\nBase class for markdown parser rules\n\n\\*/\n(function(){\n\n/*jslint node: true, browser: true */\n/*global $tw: false */\n\"use strict\";\n\nvar utils = require(\"$:/plugins/flibbles/relink/js/utils/markdown\");\n\nvar MarkdownRuleBase = function() {};\n\nMarkdownRuleBase.prototype.init = function(parser) {\n\tthis.parser = parser;\n};\n\nMarkdownRuleBase.prototype.findNextMatch = function(startPos) {\n\tthis.matchRegExp.lastIndex = startPos;\n\twhile (this.match = this.matchRegExp.exec(this.parser.source)) {\n\t\tif (utils.indexOfParagraph(this.match[0]) >= 0) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (this.maxIndent !== undefined) {\n\t\t\tvar indent = utils.indentation(this.parser.source,this.match.index);\n\t\t\tif (indent < 0\n\t\t\t || (this.parser.indent !== undefined\n\t\t\t  && (indent > this.parser.indent + this.maxIndent))) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tvar nl = this.parser.source.lastIndexOf('\\n', this.match.index-1)+1;\n\t\t\tthis.indentString = this.parser.source.substring(nl, this.match.index);\n\t\t\treturn nl < startPos ? startPos : nl;\n\t\t}\n\t\treturn this.match.index;\n\t}\n\treturn undefined;\n};\n\n\nexports.MarkdownRuleBase = MarkdownRuleBase;\n\n})();\n",
            "type": "application/javascript",
            "module-type": "global"
        },
        "$:/plugins/flibbles/relink/js/relinkoperations/text/markdowntext.js": {
            "title": "$:/plugins/flibbles/relink/js/relinkoperations/text/markdowntext.js",
            "text": "/*\\\nmodule-type: relinktextoperator\ntitle: $:/plugins/flibbles/relink/js/relinkoperations/text/markdowntext.js\ntype: application/javascript\n\nThis relinks tiddlers which contain markdown. It tries to be agnostic to\nwhichever markdown plugin you're using.\n\n\\*/\n\n/*jslint node: false, browser: true */\n/*global $tw: false */\n\"use strict\";\n\nvar Placeholder = require(\"$:/plugins/flibbles/relink/js/utils/placeholder.js\");\nvar settings = require('$:/plugins/flibbles/relink/js/settings.js');\nvar markdownHandler = settings.getType('markdown');\n\nexports[\"text/x-markdown\"] = function(tiddler, fromTitle, toTitle, options) {\n\tvar placeholder = new Placeholder();\n\tvar extraOptions = $tw.utils.extend(\n\t\t{\n\t\t\tcurrentTiddler: tiddler.fields.title,\n\t\t\tplaceholder: placeholder\n\t\t}, options);\n\tvar entry = markdownHandler.relink(tiddler.fields.text, fromTitle, toTitle, extraOptions);\n\tif (entry && entry.output) {\n\t\t// If there's output, we've also got to prepend any macros\n\t\t// that the placeholder defined.\n\t\tvar preamble = placeholder.getPreamble();\n\t\tentry.output = preamble + entry.output\n\t}\n\treturn entry;\n};\n\n",
            "module-type": "relinktextoperator",
            "type": "application/javascript"
        },
        "$:/plugins/flibbles/relink/js/utils/markdown.js": {
            "title": "$:/plugins/flibbles/relink/js/utils/markdown.js",
            "text": "/*\\\nmodule-type: library\ntitle: $:/plugins/flibbles/relink/js/utils/markdown.js\ntype: application/javascript\n\nMethods used in markdown parsing.\n\n\\*/\n\n// tiddlywiki/markdown can't handle having these characters escaped, so we\n// need to unescape them.\nvar problemChars = {\n\t\"23\": \"#\",\n\t\"24\": \"$\",\n\t\"26\": \"&\",\n\t\"2B\": \"+\",\n\t\"2C\": \",\",\n\t\"2F\": \"/\",\n\t\"3A\": \":\",\n\t\"3B\": \";\",\n\t\"3D\": \"=\",\n\t\"3F\": \"?\",\n\t\"40\": \"@\",\n};\n\nexports.encodeLink = function(title) {\n\tvar encoded = encodeURIComponent(title),\n\t\tbalance = 0;\n\tencoded = encoded.replace(/[\\(\\)]/g, function(p) {\n\t\tif (p === '(') {\n\t\t\tif (balance >=1) {\n\t\t\t\treturn '%28';\n\t\t\t} else {\n\t\t\t\tbalance++;\n\t\t\t}\n\t\t} else {\n\t\t\tif (balance <= 0) {\n\t\t\t\treturn '%29';\n\t\t\t}\n\t\t\tbalance--;\n\t\t}\n\t\treturn p;\n\t});\n\twhile (balance--) {\n\t\tvar i = encoded.lastIndexOf('(');\n\t\tencoded = encoded.substr(0, i) + '%28' + encoded.substr(i+1);\n\t}\n\t// tiddlywiki/markdown can't handle these characters escaped\n\treturn encoded.replace(/%([0-9A-F]{2})/g, function(str, code) {\n\t\treturn problemChars[code] || str;\n\t});\n};\n\n// Returns index of next paragraph, or -1\nexports.indexOfParagraph = function(text, startPos) {\n\tvar regExp = /\\n\\s*\\n/mg;\n\tregExp.lastIndex = startPos || 0;\n\tvar match = regExp.exec(text);\n\treturn match ? regExp.lastIndex : -1;\n};\n\n/** Returns how much indentation there is between pos and the previous\n * newline (or other char).\n * tabs are counted as 4 chars.\n */\nexports.indentation = function(text, pos, startChar) {\n\tvar p = text.lastIndexOf(startChar || '\\n', pos-1);\n\tvar count = 0;\n\twhile (++p < pos) {\n\t\tvar c = text.charAt(p);\n\t\tif (c === ' ') {\n\t\t\tcount++;\n\t\t} else if (c === '\\t') {\n\t\t\tcount = count + 4 - (count%4);\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn count;\n};\n\n\nexports.getSettings = function(wiki) {\n\t// Stored here so it's only calculated once, but also so it's different\n\t// per tiddler for testing\n\tif (wiki._markdownSettings === undefined) {\n\t\tvar settings = Object.create(null);\n\t\tvar text = wiki.getTiddlerText(\"$:/config/markdown/renderWikiText\");\n\t\tsettings.wikitext =  (text === undefined || text.toLowerCase() === \"true\");\n\t\ttext = wiki.getTiddlerText(\"$:/config/markdown/renderWikiTextPragma\");\n\t\tif (text) {\n\t\t\ttext = text.trim() + '\\n';\n\t\t} else {\n\t\t\ttext = '';\n\t\t}\n\t\tsettings.wikitextPragma = text;\n\t\twiki._markdownSettings = settings;\n\t}\n\treturn wiki._markdownSettings;\n};\n\n// This is the maximum length a reported caption may be\nexports.captionLength = 15;\n\n/** Abridges a string to one that is more log-friendly.\n */\nexports.abridge = function(string) {\n\tvar safe = string.replace(/\\s+/mg, ' ');\n\tif (safe.length > this.captionLength) {\n\t\tsafe = safe.substr(0, this.captionLength) + \"...\";\n\t}\n\treturn safe;\n};\n\n/**I don't actually use this, but I've kept the code around anyway.\n * The only time this plugin is installed and markdown isn't enabled would\n * be if the user forgot to install a markdown plugin, or they disabled it.\n * I GUESS Relink should still be Relinking markdown in that case.\n */\nexports.markdownEnabled = function() {\n\tif (_enabled === undefined) {\n\t\tvar test = $tw.wiki.renderText(\"text/html\", \"text/x-markdown\", \"[test](#test)\");\n\t\t_enabled = (test.indexOf(\"<a\") >= 0);\n\t}\n\treturn _enabled;\n};\nvar _enabled;\n",
            "module-type": "library",
            "type": "application/javascript"
        },
        "$:/plugins/flibbles/relink-markdown/readme": {
            "title": "$:/plugins/flibbles/relink-markdown/readme",
            "text": "Markdown support for Relink.\n\n...or Relink support for Markdown.\n\nThis supplimental plugin allows ''text/x-markdown'' files to be relinked. This means markdown linking syntax like `[Caption](#MyTiddler)` is supported. If your markdown supports wikitext markup as well, this will handle that too.\n\nThis plugin is designed for `tiddlywiki/markdown`, but it will also work for `anstosa/tw5-markdown` and others.\n"
        }
    }
}