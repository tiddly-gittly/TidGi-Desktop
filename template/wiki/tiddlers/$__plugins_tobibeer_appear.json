{
    "tiddlers": {
        "$:/plugins/tobibeer/appear/widget.js": {
            "title": "$:/plugins/tobibeer/appear/widget.js",
            "text": "/*\\\ntitle: $:/plugins/tobibeer/appear/widget.js\ntype: application/javascript\nmodule-type: widget\n\nUse the appear widget for popups, sliders, accordion menus\n\n@preserve\n\\*/\n(function(){\n\n/*jslint node: true, browser: true */\n/*global $tw: false */\n\"use strict\";\n\nvar Widget = require(\"$:/core/modules/widgets/widget.js\").widget,\n\tAppearWidget = function(parseTreeNode,options) {\n\t\tthis.initialise(parseTreeNode,options);\n\t},\n\thandlerCache = {};\n\n/*\nInherit from the base widget class\n*/\nAppearWidget.prototype = new Widget();\n\n/*\nRender this widget into the DOM\n*/\nAppearWidget.prototype.render = function(parent,nextSibling) {\n\tthis.parentDomNode = parent;\n\tthis.nextSibling = nextSibling;\n\tthis.computeAttributes();\n\tthis.execute();\n\tvar cls,button,buttonClose,hidden,reveal,shown,\n\t\t// Will hold the child widgets\n\t\tnodes = [];\n\t// Handler instance?\n\tif(this.handle) {\n\t\t// Recreate cache\n\t\tthis.getHandlerCache(this.handle,1);\n\t\t// Handle refreshes\n\t\tthis.refreshHandler();\n\t// Regular instance\n\t} else {\n\t\t// Create button\n\t\tbutton = {type:\"button\"};\n\t\t// Init button attributes\n\t\tbutton.attributes = this.setAttributes(button,\"button\");\n\t\t// Store current classes\n\t\tcls = button.attributes[\"class\"].value.trim();\n\t\t// Add unselected class\n\t\tbutton.attributes[\"class\"].value = cls + \" appear-show\" + (this.handler ? \" tc-popup-absolute\" : \"\");\n\t\t// Parse label and add to children\n\t\tbutton.children = this.wiki.parseText(\n\t\t\t\"text/vnd.tiddlywiki\",\n\t\t\tthis.show,\n\t\t\t{parseAsInline: true}\n\t\t).tree;\n\t\t// Create reveal\n\t\treveal = {type:\"reveal\",children:this.parseTreeNode.children};\n\t\t// Init reveal attributes\n\t\treveal.attributes = this.setAttributes(reveal,\"reveal\");\n\t\t// Set custom mode, if configured\n\t\treveal.isBlock = !(this.mode && this.mode === \"inline\");\n\t\t// Type popup?\n\t\tif(reveal.attributes.type && reveal.attributes.type.value === \"popup\") {\n\t\t\t// Set button attribute for popup state\n\t\t\tbutton.attributes.popup = reveal.attributes.state;\n\t\t\t// Add childnodes\n\t\t\tnodes.push(button);\n\t\t\t// Unless we have a deferred handler defined\n\t\t\tif(!this.handler) {\n\t\t\t\t// Push reveal to node tree\n\t\t\t\tnodes.push(reveal);\n\t\t\t} else {\n\t\t\t\tbutton.attributes.handler = this.handler;\n\t\t\t}\n\t\t// Not a popup\n\t\t} else {\n\t\t\t// Set reveal attribute for \"slider mode\"\n\t\t\treveal.attributes.type = {type: \"string\", value: \"match\"};\n\t\t\t// Must match current tiddler title\n\t\t\treveal.attributes.text = {type: \"string\", value: this.currentTiddler};\n\t\t\t// Button writes to state tiddler\n\t\t\tbutton.attributes.set =  reveal.attributes.state;\n\t\t\t// Sets to current tiddler\n\t\t\tbutton.attributes.setTo =  {type: \"string\", value: this.currentTiddler};\n\t\t\t// A wrapper reveal that will be hidden once the content is shown containing the button\n\t\t\thidden = {type:\"reveal\",isBlock: this.block, children:[button], attributes: {\n\t\t\t\ttype: {type: \"string\", value: \"nomatch\"},\n\t\t\t\tstate: reveal.attributes.state,\n\t\t\t\ttext: {type: \"string\", value: this.currentTiddler}\n\t\t\t}};\n\t\t\t// Endless toggling?\n\t\t\tif(!this.once) {\n\t\t\t\t// Create hide-button as a copy of the button\n\t\t\t\tbuttonClose = $tw.utils.deepCopy(button);\n\t\t\t\t// Add selected class\n\t\t\t\tbuttonClose.attributes[\"class\"].value = cls + \" appear-hide \" +\n\t\t\t\t\t(this.attr.button.selectedClass ? this.attr.button.selectedClass : \"\");\n\t\t\t\t// However, resetting the state\n\t\t\t\tbuttonClose.attributes.setTo = {type: \"string\", value: \"\"};\n\t\t\t\t// Setting the hide-button label\n\t\t\t\tbuttonClose.children = this.wiki.parseText(\n\t\t\t\t\t\"text/vnd.tiddlywiki\",\n\t\t\t\t\tthis.hide,\n\t\t\t\t\t{parseAsInline: true}\n\t\t\t\t).tree;\n\t\t\t}\n\t\t\t// Create a copy of the first reveal containing the button\n\t\t\tshown = $tw.utils.deepCopy(hidden);\n\t\t\t// Reset its children\n\t\t\tshown.children = [];\n\t\t\t// Endless toggling?\n\t\t\tif(!this.once) {\n\t\t\t\t// Add close button\n\t\t\t\tshown.children.push(buttonClose);\n\t\t\t}\n\t\t\t// No remote handler?\n\t\t\tif(!this.handler) {\n\t\t\t\t// Add slider contents\n\t\t\t\tshown.children.push(reveal);\n\t\t\t}\n\t\t\t// Switch reveal type for content reveal wrapper\n\t\t\tshown.attributes.type.value = \"match\";\n\t\t\t// Add wrapping reveals to output\n\t\t\tnodes.push(hidden,shown);\n\t\t}\n\t\t// Construct the child widgets\n\t\tthis.makeChildWidgets(nodes);\n\t\t// Render into the dom\n\t\tthis.renderChildren(this.parentDomNode,nextSibling);\n\t\t// Now, do we have a remote handler?\n\t\tif(this.handler) {\n\t\t\t// Update its state\n\t\t\tthis.addToHandlerCache(reveal);\n\t\t}\n\t}\n};\n\n/*\nCompute the internal state of the widget\n*/\nAppearWidget.prototype.execute = function() {\n\tvar self = this;\n\t// Attribute mapping\n\tthis.attr = {\n\t\t// Which attributes map to which element\n\t\tmap: {\n\t\t\treveal: {\n\t\t\t\t\"class\":1,\n\t\t\t\tposition:1,\n\t\t\t\tretain:1,\n\t\t\t\tstate:1,\n\t\t\t\tstyle:1,\n\t\t\t\ttag:1,\n\t\t\t\ttype:1\n\t\t\t},\n\t\t\tbutton: {\n\t\t\t\t\"button-class\":1,\n\t\t\t\t\"button-style\":1,\n\t\t\t\t\"button-tag\":1,\n\t\t\t\ttooltip:1,\n\t\t\t\tselectedClass:1\n\t\t\t}\n\t\t},\n\t\t// Rename duplicate attributes later\n\t\trename: {\n\t\t\t\"button-class\":\"class\",\n\t\t\t\"button-style\":\"style\",\n\t\t\t\"button-tag\":\"tag\"\n\t\t},\n\t\t// Initialize empty containers\n\t\tbutton: {},\n\t\treveal: {}\n\t};\n\t// Loop widget attributes\n\t$tw.utils.each(this.attributes,function(val,key) {\n\t\tvar next;\n\t\t// Loop mappings\n\t\t$tw.utils.each(\n\t\t\tself.attr.map,function(attr,el) {\n\t\t\t// Loop attributes for element\n\t\t\t$tw.utils.each(Object.keys(attr),function(attr) {\n\t\t\t\t// Attribute for element?\n\t\t\t\tif(attr == key) {\n\t\t\t\t\t// Store attr value\n\t\t\t\t\tself.attr[el][key] = val;\n\t\t\t\t\t// Next attribute\n\t\t\t\t\tnext = false;\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn next;\n\t\t});\n\t});\n\t// Handle all other attributes...\n\t// Store current tiddler\n\tthis.currentTiddler = this.getVariable(\"currentTiddler\");\n\t// Default button label\n\tthis.show = this.getValue(this.attributes.show,\"show\");\n\t// Label for hide-button\n\tthis.hide = this.getValue(this.attributes.hide,\"hide\");\n\t// None defined?\n\tif(!this.hide) {\n\t\t// Use default label\n\t\tthis.hide = this.show;\n\t}\n\t// Whether to only reveal the content once\n\tthis.once = this.attributes.once && this.attributes.once !== \"false\";\n\t// State shorthand\n\tthis.$state = this.attributes.$state;\n\t// Reveal mode\n\tthis.mode = this.getValue(this.attributes.mode,\"mode\");\n\t// Is this a handler instance?\n\tthis.handle = this.attributes.handle;\n\t// Remotely handle this instance?\n\tthis.handler = this.attributes.handler;\n\t// For that case we take these variables along\n\tthis.handlerVariables = (this.attributes.variables || \"\") + \" currentTiddler\";\n\t// Whether or not to keep popups\n\tthis.keep = [\"yes\",\"true\"].indexOf(\n\t\t\t(this.getValue(this.attributes.keep,\"keep\")||\"\").toLocaleLowerCase()\n\t\t) >- 1;\n\t// No explicit state?\n\tif(!this.attr.reveal.state) {\n\t\t// Calculate fallback state\n\t\tthis.attr.reveal.state =\n\t\t\t\tthis.getValue(undefined,\"default-state\") +\n\t\t\t\tthis.currentTiddler +\n\t\t\t\tthis.getStateQualifier() + \"/\" +\n\t\t\t\t(this.attr.reveal.type ? this.attr.reveal.type + \"/\" : \"\") +\n\t\t\t\t(this.mode ? this.mode + \"/\" : \"\") +\n\t\t\t\t(this.once ? \"once/\" : \"\") +\n\t\t\t\t// Append state suffix, if given\n\t\t\t\t(this.$state ? \"/\" + this.$state : \"\");\n\t}\n};\n\n/*\nSelectively refreshes the widget if needed. Returns true if the widget or any of its children needed re-rendering\n*/\nAppearWidget.prototype.refresh = function(changedTiddlers) {\n\tvar changedAttributes = this.computeAttributes();\n\t// Any changed attributes?\n\tif(Object.keys(changedAttributes).length) {\n\t\t// Refresh\n\t\tthis.refreshSelf();\n\t\treturn true;\n\t}\n\t// Global handler?\n\tif(this.handle) {\n\t\t// Handle refreshes\n\t\tthis.refreshHandler();\n\t}\n\t// Check if we're refreshing children\n\treturn this.refreshChildren(changedTiddlers);\n};\n\n/*\nRetrieves a widget parameter as either attribute, config-tiddler default or hard-coded fallback.\n*/\nAppearWidget.prototype.getValue = function(value,attr){\n\tvar def,undef,\n\t\t// Global fallbacks\n\t\tfallbacks = {\n\t\t\tshow: \"»\",\n\t\t\t\"default-state\": \"$:/temp/appear/\"\n\t\t};\n\t// If there is no value...\n\tif(value === undefined) {\n\t\t// Get default for it\n\t\tdef = this.wiki.getTiddler(\"$:/plugins/tobibeer/appear/defaults/\" + attr);\n\t\t// Got one?\n\t\tif(def) {\n\t\t\t// Check if set to undefined\n\t\t\tundef = def.getFieldString(\"undefined\");\n\t\t\t// Not undefined?\n\t\t\tif(!undef || undef === \"false\") {\n\t\t\t\t// Read default\n\t\t\t\tvalue = def.getFieldString(\"text\");\n\t\t\t}\n\t\t}\n\t}\n\t// If we still have no value\n\tif(value === undefined) {\n\t\t// Try to read from fallbacks\n\t\tvalue = fallbacks[attr];\n\t}\n\treturn value;\n};\n\n/*\nSet child-widget attributes for a given element,\ndepending on the parsed widget attributes\n*/\nAppearWidget.prototype.setAttributes = function(node,element) {\n\tvar self = this,\n\t\t// Initialize attributes object\n\t\tresult = {};\n\t// Loop attributes defined for this element\n\t$tw.utils.each(Object.keys(this.attr.map[element]),function(attr) {\n\t\tvar val,\n\t\t\t// Check if we needed to rename this attribute\n\t\t\tname = self.attr.rename[attr];\n\t\t// Not renamed?\n\t\tif(!name) {\n\t\t\t// Take attribute name as is\n\t\t\tname = attr;\n\t\t}\n\t\t// Read as widget value, default, or fallback\n\t\tval = self.getValue(self.attr[element][attr],attr);\n\t\t// Class attribute? (always for the button, for the reveal only if undefined)\n\t\tif(name === \"class\") {\n\t\t\t// Construct classes\n\t\t\tval = [\n\t\t\t\t\"appear\",\n\t\t\t\t\"appear-\" + element,\n\t\t\t\t(element === \"reveal\" && self.keep ? \"tc-popup-keep\" : \"\"),\n\t\t\t\t(self.mode ? \"appear-\" + self.mode : \"\"),\n\t\t\t\t(self.once ? \"appear-once\" : \"\"),\n\t\t\t\t(val || \"\")\n\t\t\t].join(\" \");\n\t\t}\n\t\t// Do we have a value?\n\t\tif(val !== undefined) {\n\t\t\t// Set an element tag?\n\t\t\tif(name === \"tag\") {\n\t\t\t\t// Then set it for the parseTreeNode directly\n\t\t\t\tnode.tag = val;\n\t\t\t// Set an attribute?\n\t\t\t} else {\n\t\t\t\t// Add to attribute object\n\t\t\t\tresult[name] = {type: \"string\", value: val};\n\t\t\t}\n\t\t}\n\t});\n\t// Return all attributes as an object\n\treturn result;\n};\n\n/*\nRetrieves handler cache, creates if not existing or told to\n*/\nAppearWidget.prototype.getHandlerCache = function(handler,create) {\n\t// Retrieve cache for handler\n\tvar cache = handlerCache[handler];\n\t// If not existing or asked to be created\n\tif(!cache || create){\n\t\t// Create new cache for handler\n\t\thandlerCache[handler] = {\n\t\t\t// For these states\n\t\t\thandled: {},\n\t\t\t// Refresh list\n\t\t\thandle: {}\n\t\t};\n\t\tcache = handlerCache[handler];\n\t}\n\treturn cache;\n};\n\n/*\nRetrieve notifier list for global handler and create contents accordingly\n*/\nAppearWidget.prototype.refreshHandler = function() {\n\tvar self = this,\n\t\t// Get cache for handler\n\t\tcache = this.getHandlerCache(this.handle),\n\t\t// Load refresh items from global cache for handler\n\t\thandle = cache.handle;\n\t// Got anything to handle?\n\tif(Object.keys(handle).length) {\n\t\t// Loop refresh handles\n\t\t$tw.utils.each(handle, function(node,state) {\n\t\t\t// Remove existing child node\n\t\t\tself.removeChildNode(state);\n\t\t\t// Render as child node\n\t\t\tself.children.push(self.makeChildWidget(node));\n\t\t\t// Rrnder child\n\t\t\tself.children[self.children.length - 1].render(self.parentDomNode,self.nextSibling);\n\t\t});\n\t\t// Remove entries\n\t\thandlerCache[this.handle].handle = {};\n\t}\n};\n\n/*\nRemoves a child node of a handler for a given state\n*/\nAppearWidget.prototype.removeChildNode = function(state) {\n\tvar self = this;\n\t// Loop all child widgets of handler\n\t$tw.utils.each(this.children, function(node,index) {\n\t\t// Same state?\n\t\tif(node.children[0].state === state) {\n\t\t\t// Remove any domNodes\n\t\t\tnode.removeChildDomNodes();\n\t\t\t// Delete child widget\n\t\t\tself.children.splice(index);\n\t\t\t// Done\n\t\t\treturn false;\n\t\t}\n\t});\n};\n\n/*\nChecks and updates the state for a reveal widget handling remote content\n*/\nAppearWidget.prototype.addToHandlerCache = function(reveal) {\n\tvar self = this,\n\t\t// Only one per state\n\t\tstate = reveal.attributes.state.value,\n\t\t// Retrieve cache for handler\n\t\tcache = this.getHandlerCache(this.handler),\n\t\t// Retrieve parseTree for state as cached for the handler\n\t\tcached = cache.handled[state],\n\t\t// Create vars widget wrapper containing the reveal\n\t\tvars = {type:\"vars\", children:[reveal], attributes:{}};\n\t// Loop\n\t$tw.utils.each(\n\t\t// Handler variables\n\t\t(this.handlerVariables || \"\").split(\" \"),\n\t\tfunction(v) {\n\t\t\t// No empty strings\n\t\t\tv = v.trim();\n\t\t\tif(v){\n\t\t\t\t// Store variable as vars widget attribute by...\n\t\t\t\tvars.attributes[v] = {\n\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t// Fetching the current variable value\n\t\t\t\t\tvalue: (self.getVariable(v) || \"\").toString()};\n\t\t\t}\n\t\t}\n\t);\n\t// If the state for this reveal is not the cached one\n\tif(vars !== cached) {\n\t\t// Add to refresh list, picked up by handler\n\t\tcache.handle[state] = vars;\n\t\t// Trigger refresh by writing to dummy temp tiddler for handler\n\t\tthis.wiki.setText(\"$:/temp/appear-handler/\"+this.handler,\"text\",undefined,state);\n\t}\n};\n\n// Now we got a widget ready for use\nexports.appear = AppearWidget;\n\n})();",
            "type": "application/javascript",
            "module-type": "widget"
        },
        "$:/plugins/tobibeer/appear/defaults/show": {
            "title": "$:/plugins/tobibeer/appear/defaults/show",
            "text": "»"
        },
        "$:/plugins/tobibeer/appear/defaults/mode": {
            "title": "$:/plugins/tobibeer/appear/defaults/mode",
            "text": "block"
        },
        "$:/plugins/tobibeer/appear/defaults/keep": {
            "title": "$:/plugins/tobibeer/appear/defaults/keep",
            "text": "yes"
        },
        "$:/plugins/tobibeer/appear/defaults/button-class": {
            "title": "$:/plugins/tobibeer/appear/defaults/button-class",
            "text": "tc-btn-invisible tc-tiddlylink"
        },
        "$:/plugins/tobibeer/appear/defaults/default-state": {
            "title": "$:/plugins/tobibeer/appear/defaults/default-state",
            "text": "$:/temp/appear/"
        },
        "$:/plugins/tobibeer/appear/popup.js": {
            "title": "$:/plugins/tobibeer/appear/popup.js",
            "text": "/*\\\ntitle: $:/plugins/tobibeer/appear/popup.js\ntype: application/javascript\nmodule-type: utils\n\nAn enhanced version of the core Popup to support:\n* absolute popups\n* preview popups\n* popup z-index\n\n@preserve\n\\*/\n(function(){\n\n/*jslint node: true, browser: true */\n/*global $tw: false */\n\"use strict\";\n\nvar Popup =  require(\"$:/core/modules/utils/dom/popup.js\").Popup,\n\tReveal = require(\"$:/core/modules/widgets/reveal.js\").reveal,\n\trefreshCoreReveal = Reveal.prototype.refresh;\n\n/*\nHijack and overwrite core Popup show() method\n\t=> required for absolute popup positioning, rather than relative\n*/\nPopup.prototype.show = function(options) {\n\t// The button\n\tvar cancelLevel,\n\t\tel = options.domNode,\n\t\t// Check if button absolutely positioned\n\t\tabsolute = $tw.utils.hasClass(el,\"tc-popup-absolute\"),\n\t\t// Find out what was clicked on\n\t\tinfo = this.popupInfo(el),\n\t\t// Helper to calculate the absolte offset\n\t\tcalcAbsoluteOffset = function(el) {\n\t\t\tvar e = el,\n\t\t\t\tx = 0,\n\t\t\t\ty = 0;\n\t\t\tdo {\n\t\t\t\tx += e.offsetLeft || 0;\n\t\t\t\ty += e.offsetTop  || 0;\n\t\t\t\te = e.offsetParent;\n\t\t\t} while(e);\n\t\t\treturn {left:x,top:y};\n\t\t},\n\t\toffset = {\n\t\t\tleft: el.offsetLeft,\n\t\t\ttop: el.offsetTop\n\t\t};\n\t// Level to be canceled\n\tcancelLevel = info.popupLevel;\n\t// If we clicked on a handle\n\tif(info.isHandle) {\n\t\t// Next level\n\t\tcancelLevel++;\n\t}\n\t// Cancel any higher level popups\n\tthis.cancel(cancelLevel);\n\t// Store the popup details if not already there\n\tif(this.findPopup(options.title) === -1) {\n\t\t// Store the popup details\n\t\tthis.popups.push({\n\t\t\ttitle: options.title,\n\t\t\twiki: options.wiki,\n\t\t\tdomNode: el\n\t\t});\n\t}\n\t// Calculate absolute offset?\n\toffset = absolute ? calcAbsoluteOffset(el) : offset;\n\t// Set the state tiddler\n\toptions.wiki.setTextReference(\n\t\toptions.title,\n\t\t\"(\" + offset.left +\n  \t\t\",\" + offset.top +\n\t  \t\",\" + el.offsetWidth +\n\t  \t\",\" + el.offsetHeight + \")\"\n\t);\n\t// Add the click handler if we have any popups\n\tif(this.popups.length > 0) {\n\t\tthis.rootElement.addEventListener(\"click\",this,true);\n\t}\n};\n\n// Hijack popupInfo() of core Popup ($tw.popup)\nPopup.prototype.popupInfo = function(domNode) {\n\tvar popupCount,\n\t\tisHandle = false,\n\t\tnode = domNode;\n\t// First check ancestors to see if we're within a popup handle\n\twhile(node && popupCount === undefined) {\n\t\t// When\n\t\tif(\n\t\t\t// This is a handle\n\t\t\t$tw.utils.hasClass(node,\"tc-popup-handle\") ||\n\t\t\t// Or a sticky popup\n\t\t\t$tw.utils.hasClass(node,\"tc-popup-keep\")\n\t\t) {\n\t\t\t// We set this flag (not exactly sure about the general idea here)\n\t\t\tisHandle = true;\n\t\t}\n\t\t// When\n\t\tif(\n\t\t\t// It's a reveal\n\t\t\t$tw.utils.hasClass(node,\"tc-reveal\") && (\n\t\t\t\t// Being a popup\n\t\t\t\t$tw.utils.hasClass(node,\"tc-popup\") ||\n\t\t\t\t// Or a popup-handle reveal (the choice of name seems confusing)\n\t\t\t\t$tw.utils.hasClass(node,\"tc-popup-handle\")\n\t\t\t)\n\t\t) {\n\t\t\t// Calculate popup level via zIndex\n\t\t\tpopupCount = parseInt(node.style.zIndex)-1000;\n\t\t}\n\t\t// Next Parent\n\t\tnode = node.parentNode;\n\t}\n\t// Create info object\n\tvar info = {\n\t\tpopupLevel: popupCount||0,\n\t\tisHandle: isHandle\n\t};\n\treturn info;\n};\n\n/*\nHijack core handleEvent\n*/\nPopup.prototype.handleEvent = function(event) {\n\tif(event.type === \"click\") {\n\t\t// Find out what was clicked on\n\t\tvar info = this.popupInfo(event.target),\n\t\t\tcancelLevel = info.popupLevel - 1;\n\t\t// Don't remove the level that was clicked on if we clicked on a handle\n\t\tif(info.isHandle) {\n\t\t\tif(cancelLevel < 0) {\n\t\t\t\tcancelLevel = 1;\n\t\t\t} else {\n\t\t\t\tcancelLevel++;\n\t\t\t}\n\t\t}\n\t\t// Cancel\n\t\tthis.cancel(cancelLevel);\n\t}\n};\n\n\n// Hijack readPopupState of core reveal widget to set zIndex\nReveal.prototype.refresh = function() {\n\tvar domNode,result,\n\t\twasOpen = this.isOpen;\n\t// Run core handler\n\tresult = refreshCoreReveal.apply(this,arguments);\n\t// Reference to domNode\n\tdomNode = this.domNodes[0];\n\tif(\n\t\t// If the popup is now open AND\n\t\tthis.isOpen &&\n\t\t(\n\t\t\t// It was not before\n\t   \t\twasOpen !== this.isOpen ||\n\t\t\t// Or does not have a zIndex\n\t\t\t!domNode.style.zIndex\n\t\t// AND\n\t\t) &&\n\t\t// There actually is a domNode AND\n\t   \tdomNode && (\n\t\t\t// This is a popup reveal OR\n\t\t\tthis.type === \"popup\" ||\n\t\t\t// It's a dropdown-reveal\n\t\t\t$tw.utils.hasClass(domNode, \"tc-block-dropdown\") &&\n\t\t\t$tw.utils.hasClass(domNode, \"tc-reveal\")\n\t\t)\n\t) {\n\t\t// Dynamically set z-index\n\t\tdomNode.style.zIndex = 1000 + $tw.popup.popups.length;\n\t}\n\treturn result;\n};\n\n})();",
            "type": "application/javascript",
            "module-type": "utils"
        },
        "$:/plugins/tobibeer/appear/readme": {
            "title": "$:/plugins/tobibeer/appear/readme",
            "text": "This plugin provides the ''$appear'' widget that can render popups and sliders (inline or block) as well as accordion menus.\n\n!! Attributes\n; type\n: set to `popup` to have the content appear as a popup\n; show\n: the button label\n; hide\n: the hide button label\n; mode\n: either `block` or `inline`, with respect to the inner content\n: any other mode is interpreted as block mode, without the default styles applying, e.g. drop-shadows\n; once\n: allows to click the button once, then hides it (unless the state is deleted)\n; $state\n: the widget calculates a state for you, use this to append a simple id\n; state\n: alternatively, specify a fully qualified state\n; keep\n: make popups sticky when `yes` or `true`\n; handle / handler / variables\n: allows to take the popup contents out of the flow and render them elsewhere on the page\n: required to properly create popups in table cells and other constained elements\n: specify variables to take along\n\n<br>\n\n; documentation / examples / demos...\n: http://tobibeer.github.io/tw5-plugins#appear\n"
        },
        "$:/plugins/tobibeer/appear/styles": {
            "title": "$:/plugins/tobibeer/appear/styles",
            "tags": "$:/tags/Stylesheet",
            "text": "\\rules only filteredtranscludeinline transcludeinline macrodef macrocallinline html\n\n<pre>.tc-reveal.appear-block,\n.tc-popup.appear {\n\tborder-radius: 5px;\n\tpadding: 1px 1em;\n\t<<box-shadow \"2px 2px 4px rgba(0,0,0,0.3)\">>;\n}\n.tc-popup.appear {\n\tpadding: 0 1em;\n\tbackground: <<colour background>>;\n}\n.appear-reveal.appear-inline{\nmargin-left:5px;\n}\n.appear-reveal.appear-inline.appear-once{\nmargin-left:0;\n}</pre>"
        }
    }
}