{
    "tiddlers": {
        "$:/plugins/snowgoon88/edit-comptext/config": {
            "title": "$:/plugins/snowgoon88/edit-comptext/config",
            "type": "application/json",
            "text": "{\n  \"configuration\": {\n      \"caseSensitive\" : false,\n      \"maxMatch\" : 8,\n      \"minPatLength\" : 2,\n      \"triggerKeyCombination\" : \"^ \"\n  },\n  \"template\": [{\n      \"pattern\": \"[[\",\n      \"filter\": \"[all[tiddlers]!is[system]]\",\n      \"start\": \"[[\",\n      \"end\": \"]]\"\n      },\n      {\n      \"pattern\": \"||\",\n      \"filter\": \"[all[tiddlers]!is[system]]\",\n      \"start\": \"[[|\",\n      \"end\": \"]]\",\n      \"startOffset\" : 2\n      }\n  ]\n}\n"
        },
        "$:/plugins/snowgoon88/edit-comptext/edit-comptext.js": {
            "title": "$:/plugins/snowgoon88/edit-comptext/edit-comptext.js",
            "text": "/*\\\ntitle: $:/plugins/snowgoon88/edit-comptext/edit-comptext.js\ntype: application/javascript\nmodule-type: widget\n\nTaken from original Edit-text widget\nVersion 5.1.13 of TW5\nAdd link-to-tiddler completion in framed.js and simple.js\n\nTODO : CHECK usefull, and particularly save_changes after every input ??\nTODO : where should popupNode be created in the DOM ?\nTODO : check that options are valid (numeric ?)\nvar isNumeric = function(n) {\n  return !isNaN(parseFloat(n)) && isFinite(n);\n};\n\n\\*/\n(function(){\n\n/*jslint node: true, browser: true */\n/*global $tw: false */\n\"use strict\";\n\nvar editTextWidgetFactory = require(\"$:/core/modules/editor/factory.js\").editTextWidgetFactory,\n\tFramedCompEngine = require(\"$:/plugins/snowgoon88/edit-comptext/framed.js\").FramedCompEngine,\n\tSimpleCompEngine = require(\"$:/plugins/snowgoon88/edit-comptext/simple.js\").SimpleCompEngine;\n\nexports[\"edit-comptext\"] = editTextWidgetFactory(FramedCompEngine,SimpleCompEngine);\n\n})();\n",
            "type": "application/javascript",
            "module-type": "widget"
        },
        "$:/plugins/snowgoon88/edit-comptext/examples": {
            "title": "$:/plugins/snowgoon88/edit-comptext/examples",
            "text": "The configuration file [[$:/plugins/snowgoon88/edit-comptext/config]] allow you to use the completion plugin for various usages. Here are some examples...\n\n!! Link Completion\nThe basic and default usage. Completion is triggered by `[[`, the search is among all non-system tiddlers. When selected, the `title` of the tiddler is inserted in the text, surrounded by `[[` and `]]`. This gives the following Completion Template.\n\n\n```\n{\n      \"pattern\": \"[[\",\n      \"title\": \"[all[tiddlers]!is[system]]\",\n      \"start\": \"[[\",\n      \"end\": \"]]\"\n}\t     \n```\n\n!! Link Completion and reposition to add Alias\nAnother basic usage. Completion is triggered by `||`, the search is among all non-system tiddlers. When selected, the `title` of the tiddler is inserted in the text, surrounded by `[[|` and `]]`. The cursor is positionned just before the `|`, ready for typing an Alias.\n\n```\n{\n      \"pattern\": \"||\",\n      \"filter\": \"[all[tiddlers]!is[system]]\",\n      \"start\": \"[[|\",\n      \"end\": \"]]\",\n      \"startOffset\" : 2\n      }\n\n```\n\n!! Special macro completion\nI have a 'pnjin' macro that is invoked by `<<pnjin \"TiddlerPNJName\">>` where 'TiddlerPNJName is a tiddler that hold data about a PNJ. I use tiddlywiki to organise my Role Playing Games campaigns. So, I want `<p` to trigger the completion. The search is among all non-system tiddlers tagged `PNJ` and, once selected, the title of the tiddler must be inserted surrouned by `<<pnjin \\\"` and `\\\">>`. So...\n\n```\n{\n\t\"pattern\": \"<p\",\n      \t\"title\": \"[tag[PNJ]!is[system]]\",\n      \t\"start\": \"<<pnjin  \\\"\",\n      \t\"end\": \"\\\">>\"\n}\n```\n\n!! Insert some templates or stamp or snippets into text.\nI frequently use some text pattern and I want to insert them easily. So, I could create several tiddlers, tagged '$:stamp' and in their body are the piece of texte I want to insert. The titles of these tiddlers always start with `$:/config/stamp/` (i.e. $:/config/stamp/macro, $:/config/stamp/list1, $:/config/stamp/list2). I want to trigger the completion by using `<<`, then I only want to chose among the last part of the titles of tiddlers tagged `$:stamp` so I use a mask (`$:/config/stamp/`) to only display the last part of the tiddlers title. When selectected, the `body` of the tiddler is inserted, with no surrounding strings. As a results, the Completion Template is (notice the `body` field):\n\n```\n{\n      \"pattern\": \"<<\",\n      \"body\": \"[tag[$:stamp]]\",\n      \"mask\" : \"$:/config/stamp/\",\n      \"start\": \"\",\n      \"end\": \"\"\n}\n```\n\n!! And you ?\nIf you have funny usages of completion, let me know. If you'd like to do something that is not yet possible, let me know...\n\nmail : snowgoon88(AT)gmail(DOT)com"
        },
        "$:/plugins/snowgoon88/edit-comptext/framed.js": {
            "text": "/*\\\ntitle: $:/plugins/snowgoon88/edit-comptext/framed.js\ntype: application/javascript\nmodule-type: library\n\nTaken from $:/core/modules/editor/engines/framed.js\nText editor engine based on a simple input or textarea within an iframe. This is done so that the selection is preserved even when clicking away from the textarea\n\n\\*/\n(function(){\n\n/*jslint node: true,browser: true */\n/*global $tw: false */\n\"use strict\";\n\nvar HEIGHT_VALUE_TITLE = \"$:/config/TextEditor/EditorHeight/Height\";\n\n// Configuration tiddler\nvar COMPLETION_OPTIONS = \"$:/plugins/snowgoon88/edit-comptext/config\";\nvar Completion = require(\"$:/plugins/snowgoon88/edit-comptext/completion.js\").Completion;\n\t\nfunction FramedCompEngine(options) {\n       //DEBUG console.log( \"==FramedCompEngine::creation\" );\n\t// Save our options\n\toptions = options || {};\n\tthis.widget = options.widget;\n\tthis.value = options.value;\n\tthis.parentNode = options.parentNode;\n\tthis.nextSibling = options.nextSibling;\n\n\t// Completion\n\t// Load Completion configuration as JSON\n    this._configOptions = $tw.wiki.getTiddlerData( COMPLETION_OPTIONS, {} );\n\t\n\t// Create our hidden dummy text area for reading styles\n\tthis.dummyTextArea = this.widget.document.createElement(\"textarea\");\n\tif(this.widget.editClass) {\n\t\tthis.dummyTextArea.className = this.widget.editClass;\n\t}\n\tthis.dummyTextArea.setAttribute(\"hidden\",\"true\");\n\tthis.parentNode.insertBefore(this.dummyTextArea,this.nextSibling);\n\tthis.widget.domNodes.push(this.dummyTextArea);\n\t// Create dummy popup for reading its styles\n\t//this._dummyCompletion = new Completion( this.widget, this.dummyTextArea, this._configOptions);\n\t//REMOVEthis._dummyCompletion.setAttribute(\"hidden\",\"true\");\n\t\n\t// Create the iframe\n\tthis.iframeNode = this.widget.document.createElement(\"iframe\");\n\tthis.parentNode.insertBefore(this.iframeNode,this.nextSibling);\n\tthis.iframeDoc = this.iframeNode.contentWindow.document;\n\t// (Firefox requires us to put some empty content in the iframe)\n\tthis.iframeDoc.open();\n\tthis.iframeDoc.write(\"\");\n\tthis.iframeDoc.close();\n\t// Style the iframe\n\tthis.iframeNode.className = this.dummyTextArea.className;\n\tthis.iframeNode.style.border = \"none\";\n\tthis.iframeNode.style.padding = \"0\";\n\tthis.iframeNode.style.resize = \"none\";\n\tthis.iframeDoc.body.style.margin = \"0\";\n\tthis.iframeDoc.body.style.padding = \"0\";\n\tthis.widget.domNodes.push(this.iframeNode);\n\t// Construct the textarea or input node\n\tvar tag = this.widget.editTag;\n\tif($tw.config.htmlUnsafeElements.indexOf(tag) !== -1) {\n\t\ttag = \"input\";\n\t}\n\tthis.domNode = this.iframeDoc.createElement(tag);\n\t// Set the text\n\tif(this.widget.editTag === \"textarea\") {\n\t\tthis.domNode.appendChild(this.iframeDoc.createTextNode(this.value));\n\t} else {\n\t\tthis.domNode.value = this.value;\n\t}\n\t// Set the attributes\n\tif(this.widget.editType) {\n\t\tthis.domNode.setAttribute(\"type\",this.widget.editType);\n\t}\n\tif(this.widget.editPlaceholder) {\n\t\tthis.domNode.setAttribute(\"placeholder\",this.widget.editPlaceholder);\n\t}\n\tif(this.widget.editSize) {\n\t\tthis.domNode.setAttribute(\"size\",this.widget.editSize);\n\t}\n\tif(this.widget.editRows) {\n\t\tthis.domNode.setAttribute(\"rows\",this.widget.editRows);\n\t}\n\t// Copy the styles from the dummy textarea\n\tthis.copyStyles();\n\t// Add event listeners\n\t$tw.utils.addEventListeners(this.domNode,[\n\t\t{name: \"input\",handlerObject: this,handlerMethod: \"handleInputEvent\"},\n\t\t{name: \"keydown\",handlerObject: this.widget,handlerMethod: \"handleKeydownEvent\"}\n\t]);\n\t// Insert the element into the DOM\n\tthis.iframeDoc.body.appendChild(this.domNode);\n\n\t// add Completion popup\n    this._completion = new Completion( this.widget, this.domNode, this._configOptions, this.dummyTextArea, this.iframeNode.offsetTop, this.iframeNode.offsetLeft );\n\t// print iframe offset\n\t//DEBUG console.log( \"  __iframe.offsetLeft: \"+this.iframeNode.offsetLeft );\n    //DEBUG console.log( \"  __iframe.offsetTop: \"+this.iframeNode.offsetTop );\n    \n\t// Copy all styles from dummyCompletion\n\t//$tw.utils.copyStyles(this._dummyCompletion._popNode, this._completion._popNode);\n\t// Override the ones that should not be set the same as the dummy textarea\n\t//this._completion._popNode.style.display = \"block\";\n\t//this._completion._popNode.style.width = \"100%\";\n\t//this._completion._popNode.style.margin = \"0\";\n\t// In Chrome setting -webkit-text-fill-color overrides the placeholder text colour\n\t//this._completion._popNode.style[\"-webkit-text-fill-color\"] = \"currentcolor\";\n     \n}\n\n/*\nCopy styles from the dummy text area to the textarea in the iframe\n*/\nFramedCompEngine.prototype.copyStyles = function() {\n\t// Copy all styles\n\t$tw.utils.copyStyles(this.dummyTextArea,this.domNode);\n\t// Override the ones that should not be set the same as the dummy textarea\n\tthis.domNode.style.display = \"block\";\n\tthis.domNode.style.width = \"100%\";\n\tthis.domNode.style.margin = \"0\";\n\t// In Chrome setting -webkit-text-fill-color overrides the placeholder text colour\n\tthis.domNode.style[\"-webkit-text-fill-color\"] = \"currentcolor\";\n};\n\n/*\nSet the text of the engine if it doesn't currently have focus\n*/\nFramedCompEngine.prototype.setText = function(text,type) {\n\tif(!this.domNode.isTiddlyWikiFakeDom) {\n\t\tif(this.domNode.ownerDocument.activeElement !== this.domNode) {\n\t\t\tthis.domNode.value = text;\n\t\t}\n\t\t// Fix the height if needed\n\t\tthis.fixHeight();\n\t}\n};\n\n/*\nGet the text of the engine\n*/\nFramedCompEngine.prototype.getText = function() {\n\treturn this.domNode.value;\n};\n\n/*\nFix the height of textarea to fit content\n*/\nFramedCompEngine.prototype.fixHeight = function() {\n\t// Make sure styles are updated\n\tthis.copyStyles();\n\t// Adjust height\n\tif(this.widget.editTag === \"textarea\") {\n\t\tif(this.widget.editAutoHeight) {\n\t\t\tif(this.domNode && !this.domNode.isTiddlyWikiFakeDom) {\n\t\t\t\tvar newHeight = $tw.utils.resizeTextAreaToFit(this.domNode,this.widget.editMinHeight);\n\t\t\t\tthis.iframeNode.style.height = (newHeight + 14) + \"px\"; // +14 for the border on the textarea\n\t\t\t}\n\t\t} else {\n\t\t\tvar fixedHeight = parseInt(this.widget.wiki.getTiddlerText(HEIGHT_VALUE_TITLE,\"400px\"),10);\n\t\t\tfixedHeight = Math.max(fixedHeight,20);\n\t\t\tthis.domNode.style.height = fixedHeight + \"px\";\n\t\t\tthis.iframeNode.style.height = (fixedHeight + 14) + \"px\";\n\t\t}\n\t}\n};\n\n/*\nFocus the engine node\n*/\nFramedCompEngine.prototype.focus  = function() {\n\tif(this.domNode.focus && this.domNode.select) {\n\t\tthis.domNode.focus();\n\t\tthis.domNode.select();\n\t}\n};\n\n/*\nHandle a dom \"input\" event which occurs when the text has changed\n*/\nFramedCompEngine.prototype.handleInputEvent = function(event) {\n        //DEBUG console.log( \"__framed.js::handleInputEvent\");\n\tthis.widget.saveChanges(this.getText());\n\tthis.fixHeight();\n\treturn true;\n};\n\n/*\nCreate a blank structure representing a text operation\n*/\nFramedCompEngine.prototype.createTextOperation = function() {\n\tvar operation = {\n\t\ttext: this.domNode.value,\n\t\tselStart: this.domNode.selectionStart,\n\t\tselEnd: this.domNode.selectionEnd,\n\t\tcutStart: null,\n\t\tcutEnd: null,\n\t\treplacement: null,\n\t\tnewSelStart: null,\n\t\tnewSelEnd: null\n\t};\n\toperation.selection = operation.text.substring(operation.selStart,operation.selEnd);\n\treturn operation;\n};\n\n/*\nExecute a text operation\n*/\nFramedCompEngine.prototype.executeTextOperation = function(operation) {\n\t// Perform the required changes to the text area and the underlying tiddler\n\tvar newText = operation.text;\n\tif(operation.replacement !== null) {\n\t\tnewText = operation.text.substring(0,operation.cutStart) + operation.replacement + operation.text.substring(operation.cutEnd);\n\t\t// Attempt to use a execCommand to modify the value of the control\n\t\tif(this.iframeDoc.queryCommandSupported(\"insertText\") && this.iframeDoc.queryCommandSupported(\"delete\") && !$tw.browser.isFirefox) {\n\t\t\tthis.domNode.focus();\n\t\t\tthis.domNode.setSelectionRange(operation.cutStart,operation.cutEnd);\n\t\t\tif(operation.replacement === \"\") {\n\t\t\t\tthis.iframeDoc.execCommand(\"delete\",false,\"\");\n\t\t\t} else {\n\t\t\t\tthis.iframeDoc.execCommand(\"insertText\",false,operation.replacement);\n\t\t\t}\n\t\t} else {\n\t\t\tthis.domNode.value = newText;\n\t\t}\n\t\tthis.domNode.focus();\n\t\tthis.domNode.setSelectionRange(operation.newSelStart,operation.newSelEnd);\n\t}\n\tthis.domNode.focus();\n\treturn newText;\n};\n\nexports.FramedCompEngine = FramedCompEngine;\n\n})();\n",
            "type": "application/javascript",
            "title": "$:/plugins/snowgoon88/edit-comptext/framed.js",
            "module-type": "library"
        },
        "$:/plugins/snowgoon88/edit-comptext/simple.js": {
            "text": "/*\\\ntitle: $:/plugins/snowgoon88/edit-comptext/simple.js\ntype: application/javascript\nmodule-type: library\n\nTaken from $:/core/modules/editor/engines/simple.js\nText editor engine based on a simple input or textarea tag\n\n\\*/\n(function(){\n\n/*jslint node: true, browser: true */\n/*global $tw: false */\n\"use strict\";\n\nvar HEIGHT_VALUE_TITLE = \"$:/config/TextEditor/EditorHeight/Height\";\n\n// Configuration tiddler\nvar COMPLETION_OPTIONS = \"$:/plugins/snowgoon88/edit-comptext/config\";\nvar Completion = require(\"$:/plugins/snowgoon88/edit-comptext/completion.js\").Completion;\n\nfunction SimpleCompEngine(options) {\n\t// Save our options\n\toptions = options || {};\n\tthis.widget = options.widget;\n\tthis.value = options.value;\n\tthis.parentNode = options.parentNode;\n\tthis.nextSibling = options.nextSibling;\n\n    // Completion\n\t// Load Completion configuration as JSON\n    this._configOptions = $tw.wiki.getTiddlerData( COMPLETION_OPTIONS, {} );\n\t\n\t// Construct the textarea or input node\n\tvar tag = this.widget.editTag;\n\tif($tw.config.htmlUnsafeElements.indexOf(tag) !== -1) {\n\t\ttag = \"input\";\n\t}\n\tthis.domNode = this.widget.document.createElement(tag);\n\t// Set the text\n\tif(this.widget.editTag === \"textarea\") {\n\t\tthis.domNode.appendChild(this.widget.document.createTextNode(this.value));\n\t} else {\n\t\tthis.domNode.value = this.value;\n\t}\n\t// Set the attributes\n\tif(this.widget.editType) {\n\t\tthis.domNode.setAttribute(\"type\",this.widget.editType);\n\t}\n\tif(this.widget.editPlaceholder) {\n\t\tthis.domNode.setAttribute(\"placeholder\",this.widget.editPlaceholder);\n\t}\n\tif(this.widget.editSize) {\n\t\tthis.domNode.setAttribute(\"size\",this.widget.editSize);\n\t}\n\tif(this.widget.editRows) {\n\t\tthis.domNode.setAttribute(\"rows\",this.widget.editRows);\n\t}\n\tif(this.widget.editClass) {\n\t\tthis.domNode.className = this.widget.editClass;\n\t}\n\t// Add an input event handler\n\t$tw.utils.addEventListeners(this.domNode,[\n\t\t{name: \"focus\", handlerObject: this, handlerMethod: \"handleFocusEvent\"},\n\t\t{name: \"input\", handlerObject: this, handlerMethod: \"handleInputEvent\"}\n\t]);\n\t// Insert the element into the DOM\n\tthis.parentNode.insertBefore(this.domNode,this.nextSibling);\n\tthis.widget.domNodes.push(this.domNode);\n\n\t// add Completion popup\n    this._completion = new Completion( this.widget, this.domNode, this._configOptions );\n}\n\n/*\nSet the text of the engine if it doesn't currently have focus\n*/\nSimpleCompEngine.prototype.setText = function(text,type) {\n\tif(!this.domNode.isTiddlyWikiFakeDom) {\n\t\tif(this.domNode.ownerDocument.activeElement !== this.domNode) {\n\t\t\tthis.domNode.value = text;\n\t\t}\n\t\t// Fix the height if needed\n\t\tthis.fixHeight();\n\t}\n};\n\n/*\nGet the text of the engine\n*/\nSimpleCompEngine.prototype.getText = function() {\n\treturn this.domNode.value;\n};\n\n/*\nFix the height of textarea to fit content\n*/\nSimpleCompEngine.prototype.fixHeight = function() {\n\tif(this.widget.editTag === \"textarea\") {\n\t\tif(this.widget.editAutoHeight) {\n\t\t\tif(this.domNode && !this.domNode.isTiddlyWikiFakeDom) {\n\t\t\t\t$tw.utils.resizeTextAreaToFit(this.domNode,this.widget.editMinHeight);\n\t\t\t}\n\t\t} else {\n\t\t\tvar fixedHeight = parseInt(this.widget.wiki.getTiddlerText(HEIGHT_VALUE_TITLE,\"400px\"),10);\n\t\t\tfixedHeight = Math.max(fixedHeight,20);\n\t\t\tthis.domNode.style.height = fixedHeight + \"px\";\n\t\t}\n\t}\n};\n\n/*\nFocus the engine node\n*/\nSimpleCompEngine.prototype.focus  = function() {\n\tif(this.domNode.focus && this.domNode.select) {\n\t\tthis.domNode.focus();\n\t\tthis.domNode.select();\n\t}\n};\n\n/*\nHandle a dom \"input\" event which occurs when the text has changed\n*/\nSimpleCompEngine.prototype.handleInputEvent = function(event) {\n\tconsole.log( \"__simple.js::handleInputEvent\");\n\tthis.widget.saveChanges(this.getText());\n\tthis.fixHeight();\n\treturn true;\n};\n\n/*\nHandle a dom \"focus\" event\n*/\nSimpleCompEngine.prototype.handleFocusEvent = function(event) {\n\tif(this.widget.editFocusPopup) {\n\t\t$tw.popup.triggerPopup({\n\t\t\tdomNode: this.domNode,\n\t\t\ttitle: this.widget.editFocusPopup,\n\t\t\twiki: this.widget.wiki,\n\t\t\tforce: true\n\t\t});\n\t}\n\treturn true;\n};\n\n/*\nCreate a blank structure representing a text operation\n*/\nSimpleCompEngine.prototype.createTextOperation = function() {\n\treturn null;\n};\n\n/*\nExecute a text operation\n*/\nSimpleCompEngine.prototype.executeTextOperation = function(operation) {\n};\n\nexports.SimpleCompEngine = SimpleCompEngine;\n\n})();\n",
            "type": "application/javascript",
            "title": "$:/plugins/snowgoon88/edit-comptext/simple.js",
            "module-type": "library"
        },
        "$:/plugins/snowgoon88/edit-comptext/cursor-position.js": {
            "text": "/*\\\nModule that compute the pixel position of the cursor of a text\nements.\n\nTaken from https://github.com/component/textarea-caret-position\n\n(as https://github.com/kir/js_cursor_position is not updated any more)\n\\*/\n// Fonction anonyme executée immediatement\n( function(){\n \n// The properties that we copy into a mirrored div.\n// Note that some browsers, such as Firefox,\n// do not concatenate properties, i.e. padding-top, bottom etc. -> padding,\n// so we have to do every single property specifically.\nvar properties = [\n  'direction',  // RTL support\n  'boxSizing',\n  'width',  // on Chrome and IE, exclude the scrollbar, so the mirror div wraps exactly as the textarea does\n  'height',\n  'overflowX',\n  'overflowY',  // copy the scrollbar for IE\n\n  'borderTopWidth',\n  'borderRightWidth',\n  'borderBottomWidth',\n  'borderLeftWidth',\n  'borderStyle',\n\n  'paddingTop',\n  'paddingRight',\n  'paddingBottom',\n  'paddingLeft',\n\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/font\n  'fontStyle',\n  'fontVariant',\n  'fontWeight',\n  'fontStretch',\n  'fontSize',\n  'fontSizeAdjust',\n  'lineHeight',\n  'fontFamily',\n\n  'textAlign',\n  'textTransform',\n  'textIndent',\n  'textDecoration',  // might not make a difference, but better be safe\n\n  'letterSpacing',\n  'wordSpacing',\n\n  'tabSize',\n  'MozTabSize'\n\n];\nvar isFirefox = false;\nif($tw.browser) {\n    isFirefox = window.mozInnerScreenX != null;\n}\n\nfunction getCaretCoordinates(element, position, options) {\n\n  var debug = options && options.debug || false;\n  if (debug) {\n    var el = document.querySelector('#input-textarea-caret-position-mirror-div');\n    if ( el ) { el.parentNode.removeChild(el); }\n  }\n\n  // mirrored div\n  var div = document.createElement('div');\n  div.id = 'input-textarea-caret-position-mirror-div';\n  document.body.appendChild(div);\n\n  var style = div.style;\n  var computed;\n  if($tw.browser) {\n      computed = window.getComputedStyle? getComputedStyle(element) : element.currentStyle;  // currentStyle for IE < 9\n  } \n  else {\n      computed = element.currentStyle;\n  }\n    \n\n  // default textarea styles\n  style.whiteSpace = 'pre-wrap';\n  if (element.nodeName !== 'INPUT')\n    style.wordWrap = 'break-word';  // only for textarea-s\n\n  // position off-screen\n  style.position = 'absolute';  // required to return coordinates properly\n  if (!debug)\n    style.visibility = 'hidden';  // not 'display: none' because we want rendering\n\n  // transfer the element's properties to the div\n  properties.forEach(function (prop) {\n    style[prop] = computed[prop];\n  });\n\n  if (isFirefox) {\n    // Firefox lies about the overflow property for textareas: https://bugzilla.mozilla.org/show_bug.cgi?id=984275\n    if (element.scrollHeight > parseInt(computed.height))\n      style.overflowY = 'scroll';\n  } else {\n    style.overflow = 'hidden';  // for Chrome to not render a scrollbar; IE keeps overflowY = 'scroll'\n  }\n\n  div.textContent = element.value.substring(0, position);\n  // the second special handling for input type=\"text\" vs textarea: spaces need to be replaced with non-breaking spaces - http://stackoverflow.com/a/13402035/1269037\n  if (element.nodeName === 'INPUT')\n    div.textContent = div.textContent.replace(/\\s/g, \"\\u00a0\");\n\n  var span = document.createElement('span');\n  // Wrapping must be replicated *exactly*, including when a long word gets\n  // onto the next line, with whitespace at the end of the line before (#7).\n  // The  *only* reliable way to do that is to copy the *entire* rest of the\n  // textarea's content into the <span> created at the caret position.\n  // for inputs, just '.' would be enough, but why bother?\n  span.textContent = element.value.substring(position) || '.';  // || because a completely empty faux span doesn't render at all\n  div.appendChild(span);\n\n  var coordinates = {\n    top: span.offsetTop + parseInt(computed['borderTopWidth']),\n    left: span.offsetLeft + parseInt(computed['borderLeftWidth'])\n  };\n\n  if (debug) {\n    span.style.backgroundColor = '#aaa';\n  } else {\n    document.body.removeChild(div);\n  }\n\n  return coordinates;\n}\n\n// Exporte as a module of node.js otherwise set as global\nif (typeof module != \"undefined\" && typeof module.exports != \"undefined\") {\n  module.exports = getCaretCoordinates;\n} else {\n  window.getCaretCoordinates = getCaretCoordinates;\n}\n\n})();\n",
            "type": "application/javascript",
            "title": "$:/plugins/snowgoon88/edit-comptext/cursor-position.js",
            "module-type": "library"
        },
        "$:/plugins/snowgoon88/edit-comptext/completion.js": {
            "text": "/*\\\ntitle: $:/plugins/snowgoon88/edit-comptext/completion.js\ntype: application/javascript\nmodule-type: library\n\nTry to make self-contained completion module.\n\nTo use this 'module', you need a `widget` with a kind of `editarea` node.\nI do not know the exacte prerequisites of this editarea node for the module to\nwork, but mostly one should be able to attach the following `eventHandler` to\nit:\n - input\n - keydown\n - keypress\n - keyup\nThe `widget` is needed because I use:\n - widget.document\n - widget.wiki.filterTiddlers(...)\n\nFrom the Widget, once you have a proper editarea, you just have to call\n - var completion = new Completion( theWidget, theEditAreaNode, configObject);\nwhere `configObject` is expected to have the following fields. if a field is missing, a default value will be given.\nOne can have many `elements' in the template array.\n\n{\n  \"configuration\": {\n      \"caseSensitive\" : false,\n      \"maxMatch\" : 8,\n      \"minPatLength\" : 2,\n      \"triggerKeyCombination\" : \"^ \"\n  },\n  \"template\": [{\n      \"pattern\": \"[[\",\n      \"filter\": \"[all[tiddlers]!is[system]]\",\n      \"start\": \"[[\",\n      \"end\": \"]]\"\n      }\n  ]\n}\n\nTODO : CHECK if needed\n\\*/\n\n(function(){\n\n/*jslint node: true, browser: true */\n/*global $tw: false */\n\"use strict\";\n\n// To compute pixel coordinates of cursor\nvar getCaretCoordinates = require(\"$:/plugins/snowgoon88/edit-comptext/cursor-position.js\");\n\n/** Default Completion Attributes */\nvar DEFATT = { maxMatch: 5, minPatLength: 2, caseSensitive: false, triggerKeyCombination: \"^ \" };\n\n/** \n * Struct for generic Completion Templates.\n * <ul>\n * <li>pat : pattern searched for.</li>\n * <li>filter : filter operation used to find the list of completion options</li>\n * <li>mask: replaced by \"\" when presenting completion options</li>\n * </ul>\n */\n    var Template = function( pat, filter, mask, field, start, end, startOffset  ) {\n    this.pat = pat;\n        this.filter = filter;\n    this.mask = \"^\"+regExpEscape(mask);\n    this.field = field;\n    this.start = start;\n    this.end = end;\n        this.pos = 0;\n        this.startOffset  = startOffset;\n};\n/**\n * Struct for storing completion options, as we need to memorise \n * the titles of the tiddlers when masked and when body must be displayed.\n */\nvar OptCompletion = function( title, str ) {\n    this.title = title;\n    this.str = str;\n};\n\nvar keyMatchGenerator = function(combination) {\n\tlet singleMatchGenerator = function(character) {\n\t\tif (character === '^') {\n\t\t\treturn event => event.ctrlKey;\n\t\t}\n\t\telse if (character === '+') {\n\t\t\treturn event => event.shiftKey;\n\t\t}\n\t\telse if (character === '!') {\n\t\t\treturn event => event.altKey;\n\t\t}\n\t\telse {\n\t\t\treturn event => (event.keyCode || event.which) === character.charCodeAt(0);\n\t\t}\n\t};\n\n\tlet matchers = [];\n\tfor (let i = 0; i < combination.length; i++) {\n\t\tmatchers.push(singleMatchGenerator(combination[i]));\n\t}\n\n\treturn event => {\n\t\tfor (let i = 0; i < matchers.length; i++) {\n\t\t\tif (!matchers[i](event)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t};\n};\n\n/**\n * Widget is needed in creating popupNode.\n * - widget.document\n * - widget.wiki.filterTiddlers(...)\n * - sibling : where to create the popup in the DOM.\n */\n\tvar Completion = function( editWidget, areaNode, param, sibling, offTop, offLeft ) {\n\tconsole.log( \"==Completion::creation\" );\n\n    // About underlying Widget\n    this._widget = editWidget;\n\tthis._areaNode = areaNode;\n\tthis._sibling  = (typeof sibling !== 'undefined') ?  sibling : this._areaNode;\n\tthis._offTop = (typeof offTop !== 'undefined') ?  offTop : 0;\n\tthis._offLeft = (typeof offLeft !== 'undefined') ?  offLeft : 0;\t\n\t\t\n    // Completions attributes\n    /** State */\n    this._state = \"VOID\";\n    this._template = undefined;\n    /** Best matches */\n    this._bestMatches = []; // An array of OptCompletion\n    this._idxChoice = -1;\n    /** Param */\n    // maximum nb of match displayed\n    this._maxMatch     = param.configuration.maxMatch || DEFATT.maxMatch;   \n    this._minPatLength = param.configuration.minPatLength || DEFATT.minPatLength;\n    this._caseSensitive= param.configuration.caseSensitive || DEFATT.caseSensitive;\n    this._triggerKeyMatcher = keyMatchGenerator(param.configuration.triggerKeyCombination || DEFATT.triggerKeyCombination);\n    /** Input information */\n    this._lastChar = \"\";\n    this._hasInput = false;\n    /** List of Completion Templates */\n    this._listTemp = [];\n    \n    // Read templates from Param\n    if( param.template ) {\n    \tvar idT;\n    \tfor( idT=0; idT<param.template.length; idT++ ) {\n    \t    var temp = param.template[idT];\n\t    // field 'body' ou 'title' (default)\n\t    if( temp.body ) {\t\t\n    \t\tthis._listTemp.push( \n    \t\t    new Template( temp.pattern, temp.body,\n\t\t\t\t  temp.mask ? temp.mask : \"\",\n\t\t\t\t  \"body\",\n    \t\t\t\t  temp.start, temp.end,\n                                temp.startOffset)\n    \t\t);\n\t    }\n\t    else {\n    \t\tthis._listTemp.push( \n    \t\t    new Template( temp.pattern, \n\t\t\t\t  temp.title ? temp.title : temp.filter,\n\t\t\t\t  temp.mask ? temp.mask : \"\",\n\t\t\t\t  \"title\",\n    \t\t\t\t  temp.start, temp.end,\n                                temp.startOffset )\n    \t\t);\n\t    }\n\t    //DEBUG temp = this._listTemp[this._listTemp.length-1];\n\t    //DEBUG console.log( \"__CONF : \"+temp.pattern+\":\"+temp.filter+\":\"+temp.mask+\":\"+temp.field+\":\"+temp.start+\":\"+temp.end );\n    \t}\n    }\n    // or defaut template\n    else {\n    \tthis._listTemp = [\n    \t    new Template( \"[[\", \"[all[tiddlers]!is[system]]\", \n\t\t\t  \"\", \"title\",\n\t\t\t  \"[[\", \"]]\" )\n    \t];\n    }\n    // Create Popup\n\t//this._popNode = createPopup(this._widget, this._areaNode );\n\tthis._popNode = createPopup(this._widget, this._sibling );\t\n    \n    // Listen to the Keyboard\n    $tw.utils.addEventListeners( this._areaNode,[\n\t{name: \"input\", handlerObject: this, handlerMethod: \"handleInput\"},\n\t{name: \"keydown\", handlerObject: this, handlerMethod: \"handleKeydown\"},\n\t{name: \"keypress\", handlerObject: this, handlerMethod: \"handleKeypress\"},\n    \t{name: \"keyup\", handlerObject: this, handlerMethod: \"handleKeyup\"}\n    ]);\n   \n    /** \n     * Find the bestMatches among listChoice with given pattern\n     * @param listChoice : array of String\n     * @change : this._bestMatches => array of OptCompletion\n     */\n    this._findBestMatches = function( listChoice, pattern, nbMax) {\n\t// regexp search pattern, case sensitive\n\tvar flagSearch = this._caseSensitive ? \"\" : \"i\" ;\n\tvar regpat = RegExp( regExpEscape(pattern), flagSearch );\n\tvar regpat_start = RegExp( \"^\"+regExpEscape(pattern), flagSearch );\n\tvar regMask = RegExp( this._template.mask ? this._template.mask : \"\",\"\");\n\tvar nbMatch = 0;\n\t// nbMax set to _maxMatch if no value given\n\tnbMax = nbMax !== undefined ? nbMax : this._maxMatch;\n\n\t//DEBUG console.log( \"__FIND masked=\"+regMask+\" regPat=\"+regpat);\n\n\tthis._bestMatches= [];\n\tvar otherMatches = [];\n\t// We test every possible choice\n\tfor( var i=0; i< listChoice.length; i++ ) {\n\t    // apply mask over potential choice\n\t    var maskedChoice = listChoice[i].replace( regMask, \"\");\n\t    // Test first if pattern is found at START of the maskedChoice\n\t    // THEN added to BestMatches\n \t    if( regpat_start.test( maskedChoice )) {\n\t\tif (nbMatch >= nbMax) {\n\t\t    this._bestMatches.push( new OptCompletion(\"\",\"...\") );\n\t\t    return;\n\t\t} else {\n\t\t    this._bestMatches.push( new OptCompletion(listChoice[i],maskedChoice) );\n\t\t    nbMatch += 1;\n\t\t}\n\t    }\n\t    // then if pattern is found WITHIN the maskedChoice\n\t    // added AFTER the choices that starts with pattern\n\t    else if( regpat.test( maskedChoice ) ) {\n\t\tif (nbMatch >= nbMax) {\n\t\t    // add all otherMatches to _bestMatches\n\t\t    this._bestMatches.push( new OptCompletion(\"\",\"<hr>\") ) ; //separator\n\t\t    this._bestMatches = this._bestMatches.concat( otherMatches );\n\t\t    this._bestMatches.push( new OptCompletion(\"\",\"...\") );\n\t\t    return;\n\t\t} else {\n\t\t    otherMatches.push( new OptCompletion(listChoice[i],maskedChoice) );\n\t\t    nbMatch += 1;\n\t\t}\n\t    }\n\t}\n\t// Here, must add the otherMatches\n\tthis._bestMatches.push( new OptCompletion(\"\",\"<hr>\") ) ; //separator\n\tthis._bestMatches = this._bestMatches.concat( otherMatches );\n    };\n    /**\n     * Change Selected Status of Items\n     */\n    this._next = function (node) {\n\tvar count = node.children.length;\n\t//DEBUG console.log( \"__NEXT: co=\"+count+\" nbMatch=\"+this._bestMatches.length);\n\tif( this._bestMatches.length > 0 ) \n\t    this._goto( node, this._idxChoice < count - 1 ? this._idxChoice + 1 : -1);\n\t//DEBUG this._logStatus( \"NexT\" );\n    };\n    this._previous = function (node) {\n\tvar count = node.children.length;\n\tvar selected = this._idxChoice > -1;\n\t//DEBUG console.log( \"__PREV: co=\"+count+\" nbMatch=\"+this._bestMatches.length);\n\tif( this._bestMatches.length > 0 ) \n\t    this._goto( node, selected ? this._idxChoice - 1 : count - 1);\n\t//DEBUG this._logStatus( \"PreV\" );\n    };\n    // Should not be used, highlights specific item without any checks!\n    this._goto = function (node, idx) {\n\tvar lis = node.children;\n\tvar selected = this._idxChoice > -1;\n\tif (selected) {\n\t    lis[this._idxChoice].setAttribute(\"patt-selected\", \"false\");\n\t}\n\n\tthis._idxChoice = idx;\n    \n\tif (idx > -1 && lis.length > 0) {\n\t    lis[idx].setAttribute(\"patt-selected\", \"true\");\n\t}\n    };\n    /**\n     * Abort pattern and undisplay.\n     */\n    this._abortPattern = function (displayNode) {\n\tthis._state = \"VOID\";\n\tthis._bestChoices = [];\n\tthis._idxChoice = -1;\n\tthis._undisplay( displayNode );\n\tthis._template = undefined;\n    };\n    /**\n     * Display popupNode at the cursor position in areaNode.\n     */\n    this._display = function( areaNode, popupNode ) {\n\tif ( popupNode.style.display == 'none' ) {\n\t    // Must get coordinate\n\t    // Cursor coordinates within area + area coordinates + scroll\n            var coord = getCaretCoordinates(areaNode, areaNode.selectionEnd);\n            var styleSize = getComputedStyle(areaNode).getPropertyValue('font-size');\n            var fontSize = parseFloat(styleSize); \n\t\t\n\t    popupNode.style.left = (this._offLeft+areaNode.offsetLeft-areaNode.scrollLeft+coord.left) + 'px';\n\t    popupNode.style.top = (this._offTop+areaNode.offsetTop-areaNode.scrollTop+coord.top+fontSize*2) + 'px';\n\t    popupNode.style.display = 'block';\n\t}\n    };\n    /**\n     * Undisplay someNode\n     */\n    this._undisplay = function( displayNode ) {\n\tif ( displayNode.style.display != 'none' ) {\n\t    displayNode.style.display = 'none';\n\t}\n    };\n\n     /**\n     * Used for debug\n     */\n    this._logStatus = function(msg) {\n\tconsole.log( \"__STATUS: \"+this._state+\":-\"+msg+\"- idx=\"+this._idxChoice );\n    };\n\n};\n// **************************************************************************\n// ******************************************************************eventCbk\n// **************************************************************************\n/**\n * Disable the *effects* of ENTER / UP / DOWN / ESC when needed.\n * Set _hasInput to false.\n */\nCompletion.prototype.handleKeydown = function(event) {\n    // key \n    var key = event.keyCode;\n    this._hasInput = false;\n    \n    //DEBUG console.log( \"__KEYDOWN (\"+key+\") hasI=\"+this._hasInput);\n    \n    // ENTER while selecting\n    if( (this._state === \"PATTERN\" || this._state === \"SELECT\") && key === 13 ) {\n    \tevent.preventDefault();\n    \tevent.stopPropagation();\n    }\n    // ESC while selecting\n    if( (this._state === \"PATTERN\" || this._state === \"SELECT\") && key === 27 ) {\n    \tevent.preventDefault();\n    \tevent.stopPropagation();\n    }\n    // UP/DOWN while a pattern is extracted\n    if( (key===38 || key===40) && \n\t(this._state === \"PATTERN\" || this._state === \"SELECT\") ) {\n\tevent.preventDefault();\n    }\n};\n/**\n * Means that something has been added/deleted => set _hasInput\n */\nCompletion.prototype.handleInput = function(event) {\n    this._hasInput = true;\n    //DEBUG console.log( \"__INPUT hasI=\"+this._hasInput );\n};\n\t\n/**\n * Set _lastChar, detects CTRL+SPACE.\n */\nCompletion.prototype.handleKeypress = function(event) {\n    var curPos = this._areaNode.selectionStart;  // cursor position\n    var val = this._areaNode.value;   // text in the area\n    // key \n    var key = event.keyCode || event.which;\n\t\n    this._lastChar = String.fromCharCode(key);\n    //DEBUG console.log( \"__KEYPRESS (\"+key+\") hasI=\"+this._hasInput+\" char=\"+this._lastChar );\n    //DEBUG this._logStatus( \"KEYPRESS\" );\n    \n    // Detect Ctrl+Space\n    if( this._triggerKeyMatcher(event) && this._state === \"VOID\" ) {\n\t//Find a proper Template\n\t// first from which we can extract a pattern\n\tif( this._template === undefined ) {\n\t    //DEBUG console.log(\"__SPACE : find a Template\" );\n\t    var idT, res;\n\t    for( idT=0; idT < this._listTemp.length; idT++ ) {\n\t\tres = extractPattern( val, curPos, this._listTemp[idT] );\n\t\t//DEBUG console.log(\"  t=\"+this._listTemp[idT].pat+\" res=\"+res);\n\t\t// res is not undefined => good template candidate\n\t\tif( res ) {\n\t\t    this._template = this._listTemp[idT];\n\t\t    this._state = \"PATTERN\";\n\t\t    break;\n\t\t}\n\t    }\n\t}\n\telse {\n\t    //DEBUG console.log(\"__SPACE : already a template\" );\n\t    this._state = \"PATTERN\";\n\t}\n    }\n};\n/**\n * ESC -> abort; \n * Detect [ -> VOID switch to _state=PATTERN\n * PATTERN || SELECT : ENTER -> insertText\n *                     UP/DOWN -> previous/next\n *                     pattern.length > _minPatternLength -> display  \n */\nCompletion.prototype.handleKeyup = function(event) {\n    var curPos = this._areaNode.selectionStart;  // cursor position\n    var val = this._areaNode.value;   // text in the area\n    // key a\n    var key = event.keyCode;\n    \n    //DEBUG console.log( \"__KEYUP (\"+key+\") hasI=\"+this._hasInput );\n    \n    // ESC\n    if( key === 27 ) {\n\tthis._abortPattern( this._popNode );\n\t//DEBUG this._logStatus( \"\" );\n    }\n    // Check for every template\n    if( this._hasInput && this._state === \"VOID\" ) {\n\t// check every template's pattern\n\tvar idT, template;\n\tfor( idT=0; idT < this._listTemp.length; idT++ ) {\n\t    template = this._listTemp[idT];\n\t    if( this._lastChar === template.pat[template.pos] ) {\n\t\ttemplate.pos += 1;\n\t\t//DEBUG console.log( \"__CHECK : pat=\"+template.pat+\" pos=\"+template.pos );\n\t\t// Pattern totaly matched ?\n\t\tif( template.pos === template.pat.length ) {\n\t\t    //DEBUG console.log( \"__CHECK => found \"+template.pat );\n\t\t    this._state = \"PATTERN\";\n\t\t    this._template = template;\n\t\t    \n\t\t    break; // get out of loop\n\t\t}\n\t    }\n\t    else {\n\t\ttemplate.pos = 0;\n\t\t//DEBUG console.log( \"__CHECK : pat=\"+template.pat+\" pos=\"+template.pos );\n\t    }\n\t}\n    }\n    // a pattern\n    else if( this._state === \"PATTERN\" || this._state === \"SELECT\" ) {\n\t// Pattern below cursor : undefined if no pattern\n\tvar pattern = extractPattern( val, curPos, this._template );\n\tif( key === 13 ) { // ENTER\n\t    //DEBUG console.log( \"KEY : Enter\" );\n    \t    // Choice made in the displayNode ?\n    \t    var selected = this._idxChoice > -1 && this._idxChoice !== this._maxMatch;\n    \t    //DEBUG console.log( \"   > sel=\"+selected+\" len=\"+this._bestChoices.length );\n    \t    if( selected ) {\n    \t\t//DEBUG console.log( \"   > selected\" );\n\t\tvar temp = this._bestMatches[this._idxChoice];\n\t\tvar str = temp.str;\n\t\tif( this._template.field === \"body\" ) {\n\t\t    str = $tw.wiki.getTiddlerText( temp.title );\n\t\t}\n    \t\tinsertInto( this._areaNode,\n\t\t\t    str,\n\t\t\t    pattern.start, curPos, this._template );\n\t\t// save this new content\n\t\tthis._widget.saveChanges( this._areaNode.value );\n\t    }\n\t    // otherwise take the first choice (if exists)\n\t    else if( this._bestMatches.length > 0 ) {\n    \t\t//DEBUG console.log( \"   > take first one\" );\n\t\tvar temp = this._bestMatches[0];\n\t\tvar str = temp.str;\n\t\tif( this._template.field === \"body\" ) {\n\t\t    str = $tw.wiki.getTiddlerText( temp.title );\n\t\t}\n    \t\tinsertInto( this._areaNode,\n\t\t\t    str,\n\t\t\t    pattern.start, curPos, this._template );\n\t\t// save this new content\n\t\tthis._widget.saveChanges( this._areaNode.value );\n\t    }\n\t    this._abortPattern( this._popNode );\n\t\t//DEBUG this._logStatus( \"\" );\n    \t    }\n\t    else if( key === 38 && this._hasInput === false) { // up\n\t\tthis._state = \"SELECT\";\n    \t\tevent.preventDefault();\n    \t\tthis._previous( this._popNode );\n\t\t//DEBUG this._logStatus( pattern.text );\n    \t\t//event.stopPropagation();\n    \t    }\n    \t    else if( key === 40 && this._hasInput === false) { // down\n\t\tthis._state = \"SELECT\";\n    \t\tevent.preventDefault();\n    \t\tthis._next( this._popNode );\n\t\t//DEBUG this._logStatus( pattern.text );\n    \t\t//event.stopPropagation();\n    \t    }\n    \t    else if( pattern ) { // pattern changed by keypressed\n\t\tthis._idxChoice = -1;\n    \t\t// log\n\t\t//DEBUG this._logStatus( pattern.text );\n    \t\t// Popup with choices if pattern at least minPatLength letters long\n\t\tif( pattern.text.length > (this._minPatLength-1) ) {\n\t\t    // compute listOptions from templateFilter\n\t\t    var allOptions;\n\t\t    if( this._template )\n\t\t\tallOptions = this._widget.wiki.filterTiddlers( this._template.filter );\n\t\t    else\n\t\t\tallOptions = this._widget.wiki.filterTiddlers(\"[all[tiddlers]]\");\n\t\t    this._findBestMatches( allOptions, pattern.text );\n    \t\t    this._popNode.innerHTML = \"\";\n    \t\t    //console.log( \"BC \"+ this._pattern + \" => \" + choice );\n    \t\t    if (this._bestMatches.length > 0) {\n\t\t\tfor( var i=0; i<this._bestMatches.length; i++) {\n    \t\t\t    this._popNode.appendChild( \n\t\t\t\titemHTML(this._bestMatches[i].str,\n\t\t\t\t\t pattern.text));\n    \t\t\t}\n\t\t\tthis._display( this._areaNode, this._popNode );\t\t\t\n    \t\t    }\n\t\t    else { // no matches\n\t\t\tthis._state = \"PATTERN\";\n\t\t\tthis._undisplay( this._popNode );\n\t\t    }\n\t\t}\n    \t    }\n\t    else { // no pattern detected\n\t\tthis._abortPattern( this._popNode );\n\t    }\n\t}\n\t// to ensure that one MUST add an input (through onInput())\n\tthis._hasInput = false;\n};\n// **************************************************************************\n// ******************************************************** private functions\n// **************************************************************************\n/**\n * Create popup element.\n */\nvar createPopup = function( widget, node ) {\n    // Insert a special \"div\" element for poping up\n    // Its 'display' property in 'style' control its visibility\n    var popupNode = widget.document.createElement(\"div\");\n    popupNode.setAttribute( \"style\", \"display:none; position: absolute;\");\n    popupNode.className = \"tc-block-dropdown ect-block-dropdown\";\n    // Insert the element into the DOM\n    node.parentNode.insertBefore(popupNode,node.nextSibling);\n    //CHECK the domNodes is a attribute of Widget [widget.js]\n    //CHECK this.domNodes.push(popupNode);\n    \n    return popupNode;\n};\n/**\n * Extract Pattern from text at a given position.\n *\n * Between previous template.pat (or '[[') and pos\n * \n * If no pattern -> undefined\n */\nvar extractPattern = function( text, pos, template ) {\n    // Detect previous and next ]]=>STOP or [[=>START\n    var sPat = template.pat ? template.pat : '[[';\n    var pos_prevOpen = text.lastIndexOf( sPat, pos );\n    var ePat = template.end ? template.end : ']]';\n    var pos_prevClosed = text.lastIndexOf( ePat, pos );\n    var pos_nextClosed = text.indexOf( ePat, pos  );\n    //DEBUG console.log(\"__CALC st=\"+sPat+\" -> en=\"+ePat );\n    //DEBUG console.log(\"__CALC po=\"+pos_prevOpen+\" pc=\"+pos_prevClosed+\" nc=\"+pos_nextClosed+\" pos=\"+pos);\n    pos_nextClosed = (pos_nextClosed >= 0) ? pos_nextClosed : pos;\n    \n    if( (pos_prevOpen >= 0) &&                 // must be opened\n\t((pos_prevOpen > pos_prevClosed ) ||  // not closed yet\n\t (pos_prevClosed === pos))) {          // closed at cursor\n\t//DEBUG console.log(\"     pat=\"+text.slice( pos_prevOpen+sPat.length, pos) );\n\treturn { text: text.slice( pos_prevOpen+sPat.length, pos ),\n\t\t start: pos_prevOpen,\n\t\t end: pos_nextClosed\n\t       };\n    }\n};\n/**\n * Controls how list items are generated.\n * Function that takes two parameters :\n *  - text : suggestion text\n *  - input : the user’s input\n * Returns : list item. \n * Generates list items with the user’s input highlighted via <mark>.\n */\nvar itemHTML = function (text, input ) {\n    // text si input === ''\n    // otherwise, build RegExp that is global (g) and case insensitive (i)\n    // to replace with <mark>$&</mark> where \"$&\" is the matched pattern\n    var html = input === '' ? text : text.replace(RegExp(regExpEscape(input.trim()), \"gi\"), \"<mark>$&</mark>\");\n    return create(\"li\", {\n\tinnerHTML: html,\n\t\"patt-selected\": \"false\"\n    });\n};\n/**\n * Insert text into a textarea node, \n * enclosing in 'template.start..template.end'\n *\n * - posBefore : where the 'template.pat+pattern' starts\n * - posAfter : where the cursor currently is\n */\nvar insertInto = function(node, text, posBefore, posAfter, template ) {\n    //DEBUG console.log( \"__INSERT : \"+template.pattern+\":\"+template.filter+\":\"+template.mask+\":\"+template.field+\":\"+template.start+\":\"+template.end );\n    var val = node.value;\n    var sStart = template.start !== undefined ? template.start : '[[';\n    var sEnd = template.end !== undefined ? template.end : ']]';\n    var newVal = val.slice(0, posBefore) + sStart + text + sEnd + val.slice(posAfter);\n    //console.log(\"__INSERT s=\"+sStart+\" e=\"+sEnd);\n    //console.log (\"__INSERT pb=\"+posBefore+\" pa=\"+posAfter+\" txt=\"+text);\n    //console.log( \"NEW VAL = \"+newVal );\n    // WARN : Directly modifie domNode.value.\n    // Not sure it does not short-circuit other update methods of the domNode....\n    // i.e. could use widget.updateEditor(newVal) from edit-comptext widget.\n    //      but how to be sure that cursor is well positionned ?\n    node.value = newVal;\n\n    // if startOffset in Template, set cursor at beginning of inserted value,\n    // with an Offset (usefull for aliasing links)\n    if (template.startOffset) {\n        let cursorPos = posBefore+template.startOffset;\n        node.setSelectionRange( cursorPos, cursorPos );\n    }\n    else {\n        node.setSelectionRange(posBefore+text.length+sStart.length+sEnd.length, posBefore+text.length+sStart.length+sEnd.length );\n    }\n};\n/**\n * Add an '\\' in front of -\\^$*+?.()|[]{}\n */\nvar regExpEscape = function (s) {\n    return s.replace(/[-\\\\^$*+?.()|[\\]{}]/g, \"\\\\$&\");\n};\n/**\n * Add an element in the DOM.\n */\nvar create = function(tag, o) {\n    var element = document.createElement(tag);\n    \n    for (var i in o) {\n\tvar val = o[i];\n\t\n\tif (i === \"inside\") {\n\t    $(val).appendChild(element);\n\t}\n\telse if (i === \"around\") {\n\t    var ref = $(val);\n\t    ref.parentNode.insertBefore(element, ref);\n\t    element.appendChild(ref);\n\t}\n\telse if (i in element) {\n\t    element[i] = val;\n\t}\n\telse {\n\t    element.setAttribute(i, val);\n\t}\n    }\n    \n    return element;\n};\n\n\nexports.Completion = Completion;\n\n})();\n\n    \n",
            "type": "application/javascript",
            "title": "$:/plugins/snowgoon88/edit-comptext/completion.js",
            "module-type": "library"
        },
        "$:/plugins/snowgoon88/edit-comptext/edit-comptext.css": {
            "text": "\n\\rules only filteredtranscludeinline transcludeinline macrodef macrocallinline macrocallblock\n\n/* The \\rules pragma at the top of the tiddler restricts the WikiText \n * to just allow macros and transclusion. This avoids mistakenly \n * triggering unwanted WikiText processing.\n * \n * MUST not save as text/css for macro to be processed\n*/\n\n.ect-block-dropdown li {\n    display: block;\n    padding: 4px 14px 4px 14px;\n    text-decoration: none;\n    color: <<colour tiddler-link-foreground>>; /*#5778d8;*/ \n    background: transparent;\n}\n.ect-block-dropdown li[patt-selected=\"true\"] {\n    color: <<colour tiddler-link-background>>; /*#ffffff; */\n    background-color: <<colour tiddler-link-foreground>>; /*#5778d8; */\n}\n.ect-block-dropdown li[patt-selected=\"true\"] mark {\n    background: hsl(86, 100%, 21%);\n    color: inherit;\n}\n\n",
            "type": "text/vnd.tiddlywiki",
            "title": "$:/plugins/snowgoon88/edit-comptext/edit-comptext.css",
            "tags": "[[$:/tags/Stylesheet]]"
        },
        "$:/plugins/snowgoon88/edit-comptext/readme": {
            "title": "$:/plugins/snowgoon88/edit-comptext/readme",
            "text": "!! What ?\nThis plugin adds ''completion'' when editing the body of a tiddler.\n\n* Enter completion-mode by typing `[[` or `CTRL+SPACE`\n* A list of tiddlers with a title that matches the pattern between `[[` and cursor appears\n* `UP/DOWN` keys can select a tiddler, `ENTER` to validate\n* If there is only one match, `ENTER` selects it.\n* you can specify you own trigger pattern and the list of possible completions. See [[$:/plugins/snowgoon88/edit-comptext/usage]] for more details.\n* `NEW` : after completion, the cursor can be set inside the inserted text. This allows for easier creation of \"aliased links\" (try completion with `||` for example).\n\n!! To try it or get the latest news\nSee [[http://snowgoon88.github.io/TW5-extendedit]]\n\n!! Install \n\nTo add the plugin to your own TiddlyWiki5, just drag this link to the browser window:\n\n[[$:/plugins/snowgoon88/edit-comptext]]\n\nSometime, a small configuration step is then needed\n\nin `$:/ControlPanel -> Advanced -> Editor Type -> text/vnd.tiddlywiki` you must chose `comptext` instead of `text`.\n\nReload and « voilà »...\n\nThis plugin is quite mature now :o)\n\n!! Old version\n\n* A version compatible with 5.0.8 to 5.1.11 : [[http://snowgoon88.github.io/TW5-extendedit/index_5.1.11.html]]\n\n!! Source code\nOn github [[https://github.com/snowgoon88/TW5-extendedit]]\n\nGet in touch : snowgoon88(AT)gmail(DOT)com\n"
        },
        "$:/plugins/snowgoon88/edit-comptext/usage": {
            "title": "$:/plugins/snowgoon88/edit-comptext/usage",
            "text": "''Important'' : be sure that in `$:/ControlPanel -> Advanced -> Editor Type -> text/vnd.tiddlywiki` you have chosen `comptext` instead of `text`.\n\nConfiguration of the edit-comptext plugin can be done through the tiddler [[$:/plugins/snowgoon88/edit-comptext/config]]. Use a JSON tiddler (do not forget to set the type to `application/json`. See some examples at [[$:/plugins/snowgoon88/edit-comptext/examples]]\n\nIn the `configuration` object you can set :\n\n* `caseSensitive`: `true`/`false` (is search case sensitive ?)\n* `maxMatch` : an `integer` (max number of match displayed)\n* `minPatLength` : an `integer` (minimal length of a pattern to trigger completion search)\n* `triggerKeyCombination ` : a `string` representing the key combination that triggers the autocompletion popup. To use modifier keys in your combination, use following conversions : `ctrl` -> `^`, `alt` -> `!`, `shift` -> `+`. Note: ` ` (literally a whitespace) represents the `space` key.\n\nIn the `template` array you can specify the various completion templates that will be used. Every template can have the following members.\n\n* `pattern` : `string` (pattern that triggers a completion, default \"[[\" )\n* `title` or `body`: `string` (the filter operators that gives the list of valid completions, default \"[all[tiddlers]!is[system]]\"). If you specify `body`, then the body of the tiddler will be inserted on selection.\n* `start` : `string` (when completion is chosen, start is put before the completion, default \"[[\")\n* `end` : `string` (when completion is chosen, end is put after the completion, default \"]]\")\n* `startOffset` : `interger` but OPTIONNAL. If provided, the cursor will be positionned `startOffsetè characters after the beginning of the completed text. This is useful to create aliased links using \"||\" as a trigger.\n\n!! Current body of Config Tiddler\n\n{{$:/plugins/snowgoon88/edit-comptext/config}}\n\n"
        }
    }
}